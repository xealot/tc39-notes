<!doctype html>
<meta charset="utf-8">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.6.0/github-markdown.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github-gist.min.css" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/javascript.min.js"></script>

<title>January 27th 2016 Meeting Notes</title>
<body class="markdown-body">
<p>January 27th 2016 Meeting Notes</p>
<p>Eric Farriauolo (EF), Caridy Patino (CP), Michael Ficarra (MF), Peter Jensen (PJ), Domenic Denicola (DD), Jordan Harband (JHD), Chip Morningstar (CM), Brian Terlson (BT), John Neumann (JN), Dave Herman (DH), Yehuda Katz (YK), Jeff Morrison (JM), Lee Byron (LB), Daniel Ehrenberg (DE), Lars Hansen (LHN), Nagy Hostafa (NH), Michael Saboff (MS), John Buchanan (JB), Stefan Penner (SP), Sebastian McKenzie (SMK), Waldemar Horwat (WH), MarkS. Miller (MM), Paul Leathers (PL), Sebastian Markbage (SM), Zibi Braniecki (ZB), Andreas Rossberg (ARB), Ian Halliday (IH), Keith Miller (KM), Tim Disney (TD), Misko Hevery (MH), Brad Green (BG), Kevin Smith (KS), Brad Nelson (BNN), JF Bastien (JFB), Shu-yu Guo (SYG), Rick Waldron (RW), Staś Małolepszy (STM), Dean Tribble (DT)</p>
<a href="#agenda"><h2 id="agenda">Agenda</h2></a><p><a href="https://github.com/tc39/agendas/blob/master/2016/01.md">https://github.com/tc39/agendas/blob/master/2016/01.md</a></p>
<a href="#fasttrack"><h2 id="fasttrack">FastTrack</h2></a><p>AWB: slide (Ecma to ISO)</p>
<p>AWB: ecma fast tracks it to become an ISO standard</p>
<p>AWB: slide (ECMAScript 2015 and beyond)</p>
<p>AWB: slide (the plan)</p>
<p>BT: Got a bunch of excellent editorial comments from JP22.</p>
<p>WH: The Japanese ISO delegation has been by far the most prolific in finding technical problems during our past ISO fast track reviews, but they were by no means the only ISO member to make productive comments.</p>
<p>BT: It's not clear if the other delegations are commenting or not. They feed comments via GitHub but we don't necessarily know if the GitHub input we're getting is coming from folks associated with ISO delegations. JP22 is conscientious in tagging their contributions, but I don't know if the other ones do.</p>
<p>BT: some of the issues have been editorial some are bugs or implementing concensus. Lots of pull requests for bug fixes.</p>
<p>WH: What are the natures of GitHub submissions from random entities to ES? For bug reports I'm not worried, but for more significant contributions there may be IPR issues.</p>
<p>BT: it is a heuristic, significant contributions is what matters. Some bug fixes could be considered contribution, if the contribution is
significant they have to be a registered contributor.</p>
<p>AWB: it mostly comes into play for pull requests, but it is up to the editor</p>
<p>BT: not in theory, this is in practice, Largely contributions come from people in this room, but some substantial outside contributions have occured.</p>
<p>AWB: that is the general plan, addressing the ISO issue. So one final update that merely points to our documents.</p>
<p>AWB: slide (but still need something to fast-track as update to ISO/IEC 16262:2011)</p>
<p>AWB: slide, describing the content of the ecmascript suite.</p>
<p>BT: a downside I see, right now the fast-track process allows ISO members to provide feedback. If they do not see a document, would they provide feedback? I suspect this will result in less feedback from ISO. I don't believe that is fatal, but..</p>
<p>AWB: i believe that is true, but what alternative ?</p>
<p>DH: could we submit less frequently?</p>
<p>SP: seems very strange to get feedback on old versions, and not on the latest or new version</p>
<p>YK: does everyone agree that the standard  is &quot;official&quot; is year old, would we want sony to feel required to implement an obsolete spec?</p>
<ul>
<li>general consensus *</li>
</ul>
<p>AWB: slide (ECMA to ISO)</p>
<p>AWB: should we provide a technical report for JTC1, that describes our process</p>
<p>WH: whats going to be in this document</p>
<p>AWB: the current draft is on the tc39 member area of the ecma site. (displays content on screen)</p>
<p>WH: is their more to this</p>
<p>AWB: no this is it</p>
<p>AWB: ISO people sent an email, that suggested we require a clause for a normative reference.</p>
<p>AWB: it is just a set of pointers</p>
<p>WH: This is just a bibliography without any paragraph that defines conformance. Once this gets an ISO standard number XYZ, what does it mean to conform to ISO standard XYZ? One can point to anything in a bibliography.</p>
<p>BT: do you mean, it should say must implement the entire spec</p>
<p>WH: Yes, the ISO pointer standard should have a short paragraph stating that conforming to the ISO standard is defined as conforming to the current ECMA standard that's referenced.</p>
<p>BT: we should say: If you conform to ecma-262, then you conform to the ISO spec</p>
<p>YK: are they ok with this?</p>
<p>AWB: it is actually their idea</p>
<p>BT: likely concerns exist, but something we can work out</p>
<p>YK: presumably those are one-shot things.</p>
<p>SP: everyone seems &quot;in spirit&quot;  to be on-board, we just need to deal with some of the details.</p>
<p>BT: for this body we don't have to care, because we just do our thing. No more ISO fast tracking.</p>
<p>John: how does this impact 2016 release</p>
<p>AWB: it is entirely decoupled, normative rules dictate if no specific version is specified, it implies the current version</p>
<a href="#conclusionresolution-fasttrack"><h4 id="conclusionresolution-fasttrack">Conclusion/Resolution</h4></a><ul>
<li>next meeting we will vote for this.</li>
<li>if concerns exist, please let us know before the next meeting</li>
</ul>
<a href="#ecma-262402-2016-end-game"><h2 id="ecma-262402-2016-end-game">ECMA-262/402 2016 End-Game</h2></a><p>AWB: slide (Key dates)</p>
<p>BT: the way I want to do this, at the march meeting I want us to approve what is in master, or a snapshot. I don't want to make minor tech or editorial changes. I will make fixes if major issues exist, but otherwise I wish we can leave it as is. Leaving it as a tag</p>
<p>WH: What changes are you planning on making to the spec document between now and the April 1 deadline?</p>
<p>BT: Just small editorial changes and bug fixes.</p>
<p>WH: Which, if any, of the stage 3 or 4 proposals are you planning on adding into the document between now and then?</p>
<p>BT: None. As far as proposal-level features are concerned, the 2016 standard candidate spec will be what's in it today. Enjoy Array.prototype.includes (and the exponentiation operator).</p>
<p>AWB: have you discussed what will be in?</p>
<p>BT: changelogs have all the normative changes, I can go over those</p>
<p>AWB: we don't need to know, we should likely record exactly what are the new features.</p>
<p>BT: (lists features)</p>
<p>AWB: everything that applies here, applies to ecma 402 also. ecma 402 has to go through the process on the same dates, hopefully those editors are on top of that.</p>
<p>AWB: slide (draft stability)</p>
<p>BT: istvan wants a PDF, but will accept an HTML. Some may want a PDF, but it is merely a ctrl-p of the HTML. Those that want to use it, should be aware editorial changes may be more or less useless.</p>
<p>BT: I will give ecma a zip of a snapshot of the github repo.</p>
<p>YK: the PDF seems fine</p>
<p>BT: how are links</p>
<p>YK: people should use HTML</p>
<p>BT: the original PDF had links</p>
<p>YK: people should use HTML</p>
<p>WH: HTML has formatting issues.</p>
<p>WH: PDF needs links. It's much less useful without links.</p>
<ul>
<li>general agreement *</li>
</ul>
<p>AWB: some people may want to print this thing</p>
<p>BT: i believe those days are done</p>
<p>AWB: we should provide both</p>
<p>BT: companies could be hired to accomplish this</p>
<p>SP: is this a transition period, or will be do this forever</p>
<p>AWB: ecma would like to have the PDF</p>
<p>BT: ecma wants PDF, because of ISO requiring it, now that we no longer send the full spec to ISO, this may be fine.</p>
<p>AWB: ecma wants a zip file, that can run on a local machine and it has the full high fedility document.</p>
<p>BT: yup, they can host it.</p>
<p>AWB: they will want to insert some analytics</p>
<p>BT: I'll work with them to add that.</p>
<p>AWB: in the past, I have just copied their boiler plate</p>
<p>BT: do i take the snapshot on feb 26, lets pick a date.</p>
<p>AWB: Feb 29</p>
<p>BT: ok, thats a monday</p>
<p>BT: how about march 1</p>
<p>AWB: thats fine</p>
<p>BT: so if you have anything you want in the document, get it to me well before march 1</p>
<p>WH: How many files are in the HTML spec?</p>
<p>BT: 6. The HTML, CSS, diagrams, Javascript</p>
<p>WH: Why does the archival standard spec execute Javascript? Isn't that brittle?</p>
<p>BT: it isn't required, it merely improves the experience</p>
<a href="#conclusionresolution-ecma-262402-2016-end-game"><h4 id="conclusionresolution-ecma-262402-2016-end-game">Conclusion/Resolution</h4></a><ul>
<li>30 days before the next meeting, the final draft will be provided</li>
<li>next meeting we will vote to make it ES2016</li>
<li>start the out-patent review process, you may need to alert your organizations</li>
</ul>
<a href="#ecma-archiving-and-web-hosting-issues-github-wikiecmascriptorg-etc"><h2 id="ecma-archiving-and-web-hosting-issues-github-wikiecmascriptorg-etc">Ecma archiving and web hosting issues: Github, wiki.ecmascript.org, etc.</h2></a><p>(Allen Wirfs-Brock)</p>
<p>AWB: slide (Ecma Archival Issues)</p>
<p>AWB: slide (github)</p>
<p>SP: We can likely include a snapshot of issues/pull/comments requests as part of the release</p>
<p>YK: ecma position seems correct</p>
<p>SP: AWB are you going to do this</p>
<p>AWB: yes</p>
<p>AWB: slide (ES6 archives)</p>
<p>AWB: We need a strategy, small to medium (1 -&gt; 2 weeks) could likely be covered by ecma.</p>
<p>AWB: tc39 reflector -&gt; github private repo</p>
<a href="#conclusionresolution-ecma-archiving-and-web-hosting-issues-github-wikiecmascriptorg-etc"><h4 id="conclusionresolution-ecma-archiving-and-web-hosting-issues-github-wikiecmascriptorg-etc">Conclusion/resolution</h4></a><ul>
<li>BT will set up reflector</li>
<li>AWB will work on archival.</li>
<li>AWB wil own the wiki archival process</li>
</ul>
<a href="#tc39-invited-experts-fund---proposal"><h2 id="tc39-invited-experts-fund---proposal">TC39 Invited Experts Fund - Proposal</h2></a><p>AWB: Istvan Sebestyen floated this, this is actually Istvan's deck</p>
<p>AWB: root problem is as follows, how to pay for AWB to come to the meeting.... I am an instance of the problem. We have in the past invited experts, we cannot assume it is reasonable for them to cover this. Is their a way for a group like TC39, which is made up of orgs. Is there a means for it to provide some level of support to unaffiliated individuals who would be important contributors and such.</p>
<p>YK: how does one decide who is important and who is not</p>
<p>AWB: yes, lots of practical points to discuss</p>
<p>AWB: slide (ecma: type of participants in an Ecma TC)</p>
<p><em>concern about hard limit on guests</em></p>
<p>MM: is there a hard limit?</p>
<p>DT: a hard limit of 2 observers</p>
<p>YK: the found would require a group, I am concerned that this group would be peers on TC39. As a person who would benefit from this, I would be concerned that I would have to use scarce political resources.</p>
<p>DH: this could create uncomfortable situation.</p>
<p>YK: the flip side, such indivudals seeking funds on their own would not have this problem.</p>
<p>AR: TC39 or ecma may be the wrong organization, an org may exist an external group that should cover this. An example would be the jQuery foundation (or similar)</p>
<p>AWB: slide (Proposal)</p>
<p>YK: I find this unsettling</p>
<p>BT: MS GA rep didn't like this</p>
<p>WH: Google GA rep didn't like this</p>
<p>AWB: Adobe's GA rep did</p>
<p>BT: been speaking with more people at MS</p>
<p>AWB: other orgs are also speaking about this, such as the W3c.</p>
<p>AR: I am doubt it will happen in the w3c, but i feel the best solution is something similar to the jQuery foundation sponsoring this.</p>
<p>YK: this poltically frought process</p>
<p>MM: yes, we should be careful to not erode the healthy work environment</p>
<p>TD: A minor variant that may work, ECMA may administer the found but allow individuals to self-found.</p>
<p>AWB: this sounds like a legitimate expense</p>
<p>... tax talk ...</p>
<a href="#conclusion--resolution-tc39-invited-experts-fund---proposal"><h4 id="conclusion--resolution-tc39-invited-experts-fund---proposal">Conclusion / Resolution</h4></a><hr>
<a href="#decorators"><h3 id="decorators">Decorators</h3></a><p>presenter: Yehuda Katz
link to slides:</p>
<p>YK: the champion group has grown, in good ways.</p>
<p>YK: Still at stage 1, it will likely become more clear as i progress. I hope to progress it to stage 2 in munich.</p>
<p>YK: babel/ts want to explore some ideas before we move on.</p>
<p>YK: slide (quick recap)</p>
<p>YK: slide (on classes)</p>
<p>AWB: if decorators move forward, any future new class items would need to describe how to work with decorators.</p>
<p>YK: we should discuss, but yes we should consider this,</p>
<p>YK: slide (On Object literals)</p>
<p>YK: slide (originally out of scope)</p>
<p>YK: slide (prototyped in babel and TypeScript)</p>
<p>YK: slide (Users by angular 2 and Aurelia)</p>
<p>YK: class decorators are mandatory partof those frameworks</p>
<p>YK: slide (displays examples of angular 2 and aurelia)</p>
<p>YK: someone uses all the features in the proposal have some real usages, which help with features</p>
<p>YK: ember has also experiments, using decorators in concise object literals via an addon.</p>
<p>YK: react also uses this, aka @injectProps: (shows screenshot of an example) a large part of the react ecosystem seem to be excited about</p>
<p>YK: another example is core-decorators by jay phelps, an example of generic decorators everyone can use</p>
<p>MM: so what you are saying, is decorators are relieving pressure from the language to add more specific features, as they can be implemented nicely in user-land with decorators</p>
<p>YK: TL;DR decorators are popular</p>
<p>YK: slide (motivating use cases)</p>
<p>JM: can you state the difference of class vs constructor decorator</p>
<p>YK: the constructor is not a member, and my proposals do no cover it. As putting a decorator on the constructor is isomorphic to putting it on the class</p>
<p>YK: the main use-case for constructor replacement, is to deal with the fact that the spec says 3 sings exist. unfortunately specing this is complicated and will require additional machinery</p>
<p>YK: slide (changes going forward)</p>
<p>YK: given that there is usage now, let me describe what is important. I want to maintain rough syntactic compatibility. Angular for example, should be able to provide compatible decorators, without consumers having to change.</p>
<p>YK: we should decide on @ vs #, this would likely be the only user-facing change. As it would be a simple transform.</p>
<p>YK:  slide (maintain existing capabilities for library authors)</p>
<p>MM: should we say rough</p>
<p>YK: yes, i removed 1 capability, but it appeared to not be used.</p>
<p>YK: slide (continuing requirements)</p>
<p><em>discussion about when decorator expressions are evaluated</em></p>
<p>WH: I noticed when reading your proposal that you allow decorators on methods defined inside object literals but not on plain properties inside object literals. Is that intentional?</p>
<p>YK: Not intentional. The proposal on github is old.</p>
<p>WH: In that case you'll get a syntax clash when you try to extend the object literal grammar to allow decorators on plain properties in addition to methods, regardless of whether you use @ or # to introduce decorators. The conflict will be between the tail of the decorator LHS expression and the property syntax that follows it.</p>
<p>... some discussion about jits ...</p>
<p>AR: We should collect evidence</p>
<p>YK: Some confusion, the world static confused the situation, stable would have been more work.</p>
<p>AR: I'm ready to believe that, but their are other things that could detect statically, that decorators impose</p>
<p>DH: an exampe would be, replacin an IF with a decorator, would reduce the ability to quickly analyse</p>
<p>YK: i accept that</p>
<p>AWB: is it any different then a normal predicate</p>
<p>DH: Abstractions cost</p>
<p>YK: I agree, I should not speculate</p>
<p>SP: In Ruby, metaprogramming can happen anywhere, at any time, and decorators are more stable</p>
<p>YK: you can express most metaprogramming in a visible way.</p>
<p>YK: slide (Continuing Requirements)</p>
<p>YK: We want decorators to be able to decorate everything that exists within a class, including a decorator which is generic across multiple of them</p>
<p>.. YK talks about how symmetry is hard, generic decorators working well has been a hard problem ...</p>
<p>MM: provide the decorator enough information to make these choices</p>
<p>MM: I don't recall  the concrete API, is the decorator called with sufficient information to infer ??? ?</p>
<p>YK: This is the intent; we have to implement it</p>
<p>AWB: what is the hint then?</p>
<p>YK: it is a short-hand method, vs property contains a function. We have removed this from the current indication, but we have removed it.</p>
<p>YK: a short-hand method is the same as object literal version</p>
<p>AWB: super</p>
<p>YK: i did not realize</p>
<p>YK: slide (Most common reported issues)</p>
<p>YK: one could have a reflect.defineField that  doesn't work outside of class intanstiation time.</p>
<p>....lots of hard to track/write up conversation, we need a stenographer....</p>
<p>YK continues to present read slide (Most Common reported issues)</p>
<p>YK: extend and decorators need to collaborate, if you could know your superclass was being subclassed a collaborating decorator would not be required.</p>
<p>YK: slide (Changes Max-Min)</p>
<p>YK: havin to feature test the object to figure this out, is unfortunate.</p>
<p>YK: When adding an additional descriptor, you may need access to other properties. For example, _fullName may want fullName accessor. But with private this would not work, so I proposed an abstraction that allowed reflection of the private slot. Decorating a private slot, should give access to the private slot</p>
<p>MM: I don't know if I agree, but we have a session later this.</p>
<p>YK ...diagrams something..</p>
<p>AWB: wouldn't it be better to have a decorator, that decorates  this specifically installing the appropriate slots</p>
<p>MM: the exploration in private state that unified the weakMap view on how to name the private state and the slot view, was to avoid reifing the name of the private slot. To postpone the issue</p>
<p>YK: i dont' think that is realted</p>
<p>MM: the get/set functions that we are passing to the private slot..</p>
<p>Yk: they don't know the name</p>
<p>MM: the get/set functions are in a sense the reification of the name as a WeakMap</p>
<p>YK: ...</p>
<p>YK: it takes a ths</p>
<p>YK: that is a tracking feature of what we postponed</p>
<p>YK: maybe that was urgent, but I decided it is way to speculative, we can retrofit it later.</p>
<p>YK: i bought it up last meeting with more examples, I think it is unlikely we wont need, as it will cause grief. But we can postpone.</p>
<p>YK: private slots and fields will feel very similar, things that make them not compat will be a problem</p>
<p>MM: i understand</p>
<p>YK: thats all  stuff i removed, I worked with ron and angular folks on a mirror based API. Which is the result of last meetings discussion. As it turns out, it is a hard to design API. I would like to propose a seperate mirror proposal, maybe at the next meeting I attend. Rather then passing in a target/name you get a mirror, with APIs that allow your to perform the required operations. The idea is to encapsolate the whole problem in a specific API.</p>
<p>YK: I think their are many cases were the thunks are not require, some still do. Static fields do, property fields dont.</p>
<p>JM: that would be a change in properties, back to what they were before</p>
<p>YK: Static fields are more like fields then they are like properties. People really wanted to model them the same as properties.</p>
<p>E: Why doesn't it work</p>
<p>YK: Abunch of issues, TL;DR you want to be able to say, class C, saying static singleton is class C.</p>
<p>DE: is their any case other then the self reference case?</p>
<p>YK: classes have this problem</p>
<p>E: this is a TDZ</p>
<p>YK: people don't want it to be TDZ</p>
<p>JM: I think mkaing static fields fields instead of properties, feels ok. I haven't found any issues.</p>
<p>E: isnt it already a problem?</p>
<p>DE: which TDZ don't you want to add</p>
<p>E: no fields, but the self referential inner binding gets wierd up at the end, instead of the beginning.</p>
<p>YK: you are correct, in one interpretation their can be a TDZ, but I would like to avoid that</p>
<p>YK: the timing is complicated</p>
<p>AWB: this is a general problem with these initializers, i think the last time we talked about it we assumed their were issues.</p>
<p>YK: instance initializers don't have this exact problem</p>
<p>E: these things will be wired up before they run</p>
<p>YK: there may be issues, the TL;DR static fields are fields not property</p>
<p>AWB: all a static field is a definition of a property on a constructor</p>
<p>YK: the definitiation is an instruction to install but not right now</p>
<p>AWB: static field name may be a property name, we will need to define the order</p>
<p>JM: prior we were going to evaluate them as we install them</p>
<p>JM: now we treat them as a description for installation</p>
<p>AWB: i don't think thats right</p>
<p>YK: i feel we will want class decorators to modify the constructor, if we do that the static properties will have been installed on the original constructor. But the static fields will be install on the wrong constructor</p>
<p>AWB: We have to define the ordering</p>
<p>AWB: a field is something that is part of a class definition, but when the instance is created the field is installed.</p>
<p>JM: At class definition time we will need to define the ordering</p>
<p>YK: this is basically the discussion that caused me to think it is not important for use to.... The timing for initializers and instantiation is all very observable. We need to be careful, as to not tie our hands to much. At the point we discover a field that may not be time it is installed</p>
<p>YK: many different factors, suggest specifiying static field imparatively</p>
<p>AWB: i believe static fields, and object literals should share the same rule</p>
<p>YK: i believe</p>
<p>AWB: it would be disturbing, if I had an object literal with two decorated properties, and a class with two static properties, and observed a different initialization order.</p>
<p>DH: most class systems have several phases,  reality is subtle</p>
<p>YK: decorators interleaving with the initializer expressions.</p>
<p>YK: all decorators run before initializers</p>
<p>DH: instance initialzer expression happen at instantiation time, the whole idea of top to bottom left to right doesn't work</p>
<p>AWB: it doesn't work for instance stuff</p>
<p>DH: there is only one syntactic block</p>
<p>DH: there has ot be some amount of interleaving of stages</p>
<p>MM: something factually wrong about what you said, top -&gt; bottom, left -&gt; right, can be made without conflict if the instance fields and properties are set in the constructor</p>
<p>YK: one world view, static side is an instantion of a singleton side. You execute it as a single class, Another world view, is to embed the object literal. Both are valid and we need to decide which one</p>
<p>WH: the problem is, in C++ it is possible to have a static property whose initialized value is an instance of the same class. This is useful but has unexpected consequences in C++. Because they let you do that, now constexpr static value initializers cannot call static constexpr functions defined earlier in the class!</p>
<p>YK: What i said is true</p>
<p>AWB: if we don't the scoping rules get complicated</p>
<p>YK: it is orhogonal</p>
<p>YK: if it is a singleton class, that is instantiated immidately,  we would run the decorators top -&gt; bottom, followed by the initializers. Because they are seperate.</p>
<p>AWB: umm</p>
<p>YK: this should be obvious, static fields either as something as embedding an object literal in a class, or an immediate invoked class</p>
<p>AWB: what does it mean to embed an object literal</p>
<p>YK: two semantics, object assign...</p>
<p>AWB: we know semantically, that static fields/properties become own properties of the constructor properties</p>
<p>YK: both world views are consistent here</p>
<p>AWB: we are defining properties, so the two questions are when is the own property created on the constructor object. And when is the value computed that is the value of the property.</p>
<p>YK: the way classes work, there is a seperation of declaration of the class and instances</p>
<p>MM: we aren't talking about the instances</p>
<p>YK: it is impossible to explain these seperately</p>
<p>MM: what happen at class eval time</p>
<p>YK: their is a, i think many people here assume that you should not run the decorators and then the expression that is wrong. It is not my sense, and I'm trying to describe why.</p>
<p>YK: the only way it is observable without  decorators is self reference.</p>
<p>AWB: this goes back to static fields</p>
<p>YK: I tried that, and WH said we should disallow self reference</p>
<p>WH: no i said, we need to clear up the ambiguity</p>
<p>JM provides some diagraming.</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>{
    
      <span class="hljs-keyword">static</span> someFieldA = A; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">---</span> <span class="hljs-attr">1.</span> <span class="hljs-attr">record</span> <span class="hljs-attr">this</span>; &lt;<span class="hljs-attr">--</span> <span class="hljs-attr">4.</span> <span class="hljs-attr">intiatiate</span>
      
      <span class="hljs-attr">bar</span>() { &lt;<span class="hljs-attr">--</span> <span class="hljs-attr">2.</span> <span class="hljs-attr">assign</span> <span class="hljs-attr">this</span>
      }
} &lt;<span class="hljs-attr">--</span> <span class="hljs-attr">3.</span> <span class="hljs-attr">end</span>

<span class="hljs-attr">Foo</span>;
</span></span></code></pre>
<p>MM: when does Foo get bound</p>
<p>YK: at the end</p>
<p>AWB: i don't believe the spec..</p>
<p>MM: from within the class, if you execute a reading of the variable Foo before you get to the end of the }, you are in a TDZ</p>
<p>MM: the things that are creating observable side-affects are the execution of A, but the instalation of bar is not observable</p>
<p>YK: this is today, but decorators/blocks/computed property names etc, make this observable</p>
<p>AWB: computed properties are the way to bump into the TDZ today.</p>
<p>YK: the partially initialized class is not observed</p>
<p>MM: if you are executing the get of the name Foo, you get a TDZ violation</p>
<p>YK: i would like to avoid this</p>
<p>MM: im trying for a factual understanding</p>
<p>YK: you are correct</p>
<p>WH: what scope are the initializers run in</p>
<p>YK: current lexical</p>
<p>MM: they would refer to lexical names, names of properties are not lexical</p>
<p>AWB: elThis is really a discussion...</p>
<p>YK: I believe we will need to make static fields, which is why i was initially over thunking.</p>
<p>YK: with mirrors you don't get the actual objects</p>
<p>AWB: is there a concrete API</p>
<p>BT: there is a must discuss topic about walking down the prototype chain</p>
<p>YK: i have no more slides</p>
<p>YK: We want to avoid viewing partially iniitialized state</p>
<p>....</p>
<p>MM: we should revisit this.</p>
<p>YK: i just reasoned from the use-cases</p>
<p>YK: slide (Property decorator, v.last)</p>
<p>AWB: mirrors on objects, and mirrors on function definitions are quite different</p>
<p>MM: function definitions are not reified objects</p>
<p>YK: for v0 it hasn't come up</p>
<p>AWB: it may be relevant to constructors, you may want to see a method definition.</p>
<p>WH: I have the same point, if the mirror mirrors a function it can call rather than a function creation descriptor, what is the point of the mirror, why not just use the function?</p>
<p>YK: the open question, is a mirror the snapeshop, or a singleton object that mirrors the entity.</p>
<p>WH: even a snapshot is dangerous, as it could give access to mutable state.</p>
<p>YK: why?</p>
<p>WH: Shallow snapshot or deep? A shallow snapshot can point to newly created internal mutable state that the class wasn't expecting to have gotten loose yet.</p>
<p>SP: i believe a shallow snapshot is being described</p>
<p>MM: a deep snapshot is off the table</p>
<p>DE: <em>trying to interrupt to switch to a different agenda item</em> can we move this to a break out?</p>
<p>BT: this is relevant, but lets avoid rambling</p>
<p>YK: a snapshot may be wrong, if someone wants a stable reference. Which enables talking about that entity.</p>
<p>AWB: something is bothering me, in ECMAScript, other then modules. Have two sorts of constructs, which have complex evaluation semantics, that result in the creation of one or more objects.</p>
<ol>
<li>object literals (sorta complex)</li>
<li>class definitions (very complex)</li>
</ol>
<p>It seems like fundamentally as we talk about decorators, we want to formalize those.</p>
<p>MM: I feel like I have learned something</p>
<p>AWB: i the piece I am missing, although you may have it in your head, but I would really like to 1 and 2 formalized.</p>
<p>YK: everything you said rings true to me, my current.. To go through the runtime semantics, I should submit this. It is reasonably clear where things go.</p>
<p>WH: i dont think so</p>
<p>YK: im not saying anyone can do this, but AWB analysis is correct</p>
<p>AWB: one could imagine a hook point, a processing pipeline that every class definition goes though. This could enable the extends clause aswell. This elevates the control</p>
<p>MM: it is a new way to think about it for me, I really like it. I have always thought about decorators as merely desugaring. But really, it is hooking the complex initialization process.</p>
<p>YK: yes, the motivation is to enable flexibility in the current declarative blob. I agree with the analysis. I believe it is correct to address this. We should discuss the snapshotting in a breakout. I believe having one mirror that lives the entire life.</p>
<p>MM: decorators thought of as multi stage programming model</p>
<p>YK: i think my last topic was quite long</p>
<p>MM: it is possible that the presentation was only understandable with this new world view.</p>
<p>MM: the hooking of instantiation if very distinct from multi-stage programming.</p>
<p>YK: yes, we should talk about this in a break out.</p>
<p>YK: ok, my question. I don't know how people feel about non-snapshots.</p>
<p>MM: Deep snapshots won't work, shallow are making a promise they can't deliver.</p>
<p>MM:  the classic reflection APIs I am aware of are live.</p>
<p>MM: decorating reified things, vs multi-stage programming. Determining what the program is vs determining the value</p>
<p>YK: I agree, that seems fine. Im not sure what my next steps are</p>
<p>WH: it would be more productive if this was less vague, nothing we can carry on productively until that.</p>
<p>YK: that doesn't match what I need.</p>
<p>MM: as TC39 this isn't quite productive</p>
<p>WH: By more concrete, I mean a less vague proposal that we can discuss, not start implement something right away. We're not at the stage where we should be implementing yet.</p>
<p>DE: can you take an idea on those proposals and write it up</p>
<p>MM: any one of these perspectives needs to be fleshed out.</p>
<p>MM: fleshing out your persective is wonderful, fleshing out mutiple is also wonderful</p>
<p>YK: it was roughly fleshed out...</p>
<p>DE: I have not seen a sufficiently detailed proposal. Can you share a link</p>
<p>YK: i can send links, but their may be not something sufficiently speced out</p>
<p>MM: What is bothing me, is that as a designer you seem to be straddling multiple perspectives.</p>
<p>WH: the problem is, togglilng perspectives makes discussions compleciated</p>
<p>YK: tell me how</p>
<p>WH: For example, it all depends on the ordering of initialization — the different world views conflict on this.</p>
<p>E: isn't that the crux of the design of the whole thing the point of this</p>
<p>E: he is trying to figure out</p>
<p>YK: i am asking how to make this more conrete</p>
<p>MM: their are 3 distinct perspectives</p>
<ol>
<li>classic OO Design Patterns book: decoration replaces value with similar value, typically wrapper of original</li>
<li>the hooking of the instantiation process</li>
<li>mutli-stage perspective</li>
</ol>
<p>These are very distinct, I would prefer to see one perspective fleshed out, this will help provide a more coherent model.</p>
<p>YK: I believe I am in the second camp, what leads you to believe I am not.</p>
<a href="#conclusionresolution-tc39-invited-experts-fund---proposal"><h3 id="conclusionresolution-tc39-invited-experts-fund---proposal">Conclusion/Resolution</h3></a><p>AWB + MM + YK will break out.</p>
<a href="#objectprototype-security-issue-with-proxy"><h3 id="objectprototype-security-issue-with-proxy">Object.Prototype Security issue with Proxy</h3></a><p>presenters: Dan Ehrenberg / Jeff Walden</p>
<p>JW: slide (the attack: same-origin polciy workaround)</p>
<p>WH: we would have more of a problem if we expanded JS syntax?</p>
<p>JW/DE: slide (Why not, and not earlier?)</p>
<p>JW: getters are more constrained, but it is slightly harder.</p>
<p>YK: this seems also bad</p>
<p>YK: can you force SW to cache the opaque thing.</p>
<p>JW: the browser cache is sufficient, each new script element gets invoked.</p>
<p>YK: throttling that seems like one way to mitigate</p>
<p>… some discussion to clarify the attack vectors of CSRF …</p>
<p>JW: slide (The attack: Some-origin policy workdaround)</p>
<p>JW: Object.prototype/ Window.prototype. EventTarget.prototype</p>
<p>WH: Could the system say, this is not a a script?</p>
<p>MM: there is a header that can be used</p>
<p>DE: sights should use that, but that isn't sufficient.</p>
<p>JW: the browsers must support the flexilibty, due to far too much content depending on this.</p>
<p>JW: slide (...)</p>
<p>JHD: would [] cause the same issue wrt Array.prototype?</p>
<p>JW: no, not observable</p>
<p>JW: slide (Why not, and not earlier)</p>
<p>DE: i added some counters to chrome, and discovered far to many such occurances. Forcing mime-type/no-snift would break the web.</p>
<p>JW: slide (one solution: lock down <code>__proto__</code>)</p>
<p>AWB: ECMAScript requires that the global object had object.prototype in the chain.</p>
<p>JW: as of yesterday release FF ships with an immutable global object proto chain, with no compat issues so far.</p>
<p>JW: alpha 12 weeks, beta for 6 weeks. still no issues. (October)</p>
<p>YK: if you want to do this, we may explore the realm API.</p>
<p>JW: why?</p>
<p>DE: BT said they have an embedding object that uses this.</p>
<p>YK: you can imagine a realm API, that would allow a proxy wrapped global.</p>
<p>MM: wouldn't that cause the issue.</p>
<p>SP: no, the custom realm would not get script tags invoked with it in</p>
<p>YK: We should make sure that we also prevent the attacker from using realms for this, so being sure we can't get the script tag behavior in it.</p>
<p>JW: slide (but how?)</p>
<p>A. make object.prototype exotic
B. add a MOP operation</p>
<p>MM: i've wanted option B</p>
<p>BT: are you ok with A. now?</p>
<p>MM: yes, we should explore B later.</p>
<p>YK: is it possible to say, it can't be a proxy?</p>
<p>DE: The V8 team had an idea, to prevent the global trap to be a proxy</p>
<p>MM: it would allow the ability to discover whether an object is a proxy or not.</p>
<p>... discussions. some rabbit whole ...</p>
<p>MM: this is fairly strong, re: web compat</p>
<p>YK: it is not obvious to me, as we have seen IE ship for years, and only when chrome ships do we notice the web compat issue.</p>
<p>DE: we will have moderate evidence by march when this freezes</p>
<p>DE: IE has some anti phishing technique that no one is quite sure how it works.</p>
<p>MM: i am in-favour of accepted ??? now</p>
<p>DD: I second</p>
<p>MM: thank you Mozilla for doing this experiment.</p>
<a href="#conclusionresolution-tc39-invited-experts-fund---proposal"><h3 id="conclusionresolution-tc39-invited-experts-fund---proposal">Conclusion/Resolution</h3></a><ul>
<li>lets do A (merge the PR now)</li>
<li>TC expresses interest in B, it requires a proposal (will be stage 0 once written)</li>
</ul>
<a href="#quick-interjection-method-param-decorators-function-expression-decorators-yk-mh"><h2 id="quick-interjection-method-param-decorators-function-expression-decorators-yk-mh">quick interjection: method param decorators, function expression decorators (YK, MH)</h2></a><p>YK: stage 0 for function decorators?</p>
<p>AWB/MM: stage 0 is exploratory, make it part of the same proposal?</p>
<p>… discussion about splitting/decoupling proposals …</p>
<p>… MH putting up slides …</p>
<p>MH: first slide, method param decorators example: <code>refresh(@lastRefreshTime timeStamp) { … }</code> as example</p>
<p>YK: additional metadata about the param they're attached to</p>
<p>MM: can not change meaning?</p>
<p>YK/MH: can change meaning. decorator gets extra info to identify that it is a function param.</p>
<p>MM: happy with stage 0.</p>
<p>MH: function param decorators: <code>schedule(@memoize (value) =&gt; ...)</code></p>
<p>WH: Syntax conflict with the method param decorator example <code>@leg('right') rightLeg</code>. When used with arrow functions above, the <code>@memoize</code> decorator would swallow the arrow parameter list <code>(value)</code>, just like the <code>@leg</code> decorator swallows <code>('right')</code>.</p>
<p>MH: corrected function param decorators example: <code>schedule(@memoize function (value) { … })</code></p>
<p>… discussion that clarifies that they could replace the value, like all decorators …</p>
<p>MM: keep as separate stage 0 proposals</p>
<p>MF: tl;dr about problem trying to be solved?</p>
<p>MH: 1) dependency injection, example shows on constructor parameters</p>
<p>MH: motivation: testing (@timeout), @flaky, @disabled, @slow/@expensive, @description, @async, etc</p>
<a href="#conclusionresolution-quick-interjection-method-param-decorators-function-expression-decorators-yk-mh"><h4 id="conclusionresolution-quick-interjection-method-param-decorators-function-expression-decorators-yk-mh">Conclusion/Resolution</h4></a><ul>
<li>Method param decorators at stage 0</li>
<li>Function expression decorators at stage 0</li>
</ul>
<a href="#functiontostring--functionisportable-mf"><h2 id="functiontostring--functionisportable-mf">Function#toString &amp;&amp; Function#isPortable (MF)</h2></a><p>Slides: <a href="https://docs.google.com/presentation/d/1o8jVhyVHljCFyXdxe-V4X1pUmCgx0FuFvEO0fFP4LJU/edit">https://docs.google.com/presentation/d/1o8jVhyVHljCFyXdxe-V4X1pUmCgx0FuFvEO0fFP4LJU/edit</a></p>
<p>MF: slides: current stage 1</p>
<p>MF: original goals:</p>
<ul>
<li>remove forward-incompatible requirement</li>
<li>clarify &quot;functionally equivalent&quot;</li>
<li>standardize string representation</li>
<li>clarify &quot;actual characteristics&quot;</li>
</ul>
<p>MF: revised goals:
- define &quot;portability&quot; with <code>Function#isPortable</code>
- make a guarantee about the behavior of portable functions after deserialization in an equivalent lexical context</p>
<p>MF: what does &quot;portable&quot; mean slide:
- a function F defined in a lexical context L is portable is any function generated from the eval of Function#toString in L has a [[Call]] that's indistinguishable from F.[[Call]]</p>
<p>MM: closest to &quot;no free variables&quot; that you want is &quot;no free vars besides standard globals&quot;. this might allow failing on the sending side instead of the receiving side.</p>
<p>JHD: use case of &quot;list the free vars&quot; might be, user deciding if they can send a function to a webworker for example and reconstitute it safely</p>
<p>MM: allows description of behavior to be moved</p>
<p>DH: perhaps isPortable shouldn't be something we encourage people to use and we should put it not on Function.prototype</p>
<p>WH: Why did you define the concept of portability?</p>
<p>AWB: when reading the agenda, i didn't know what &quot;isPortable&quot; meant, nor an intuitive sense</p>
<p>MF: that's why i've defined it on this slide</p>
<p>WH: <em>commenting on slide with definition of portability in terms of function observational indistinguishability</em>: What does it mean to be indistinguishable? If functions A and A' both return the current time, are they indistinguishable? If A returns 5 on big-endian machines and 7 on little-endian machines and its clone A' happens to run on a different endianness from A, are they indistinguishable?</p>
<p>MF: ?</p>
<p>MF: slide (goals);</p>
<p>YK: some function exist, which when calling toString may not produce an evalable function.</p>
<p>MM: MF is addressing that, but it doesn't answer, among functions that give you an evaluable string</p>
<p>MF: slide (what is the lexical context?)</p>
<p>MF: slide (what isn't portable)</p>
<p>YK: does the proposal introduce isPortable false, that is evalable?</p>
<p>YK: isPortable means, is evaluable then.</p>
<p>MF: slide (what isn't portable)</p>
<p>MM: isPortable is things that will evaluated without a syntax error.</p>
<p>MF shares spec text</p>
<p>ARB: indistinguishablity criterion is trying to use obsrvational equivalence, which is superhard even for much simpler languages. Moreover, this requirement is impossible.</p>
<p>WH: Any kind of definition of isPortable like this is not sufficient to meet the indistinguishability criterion. There are plenty of places where ECMAScript gives implementations latitude in how they implement features (sort, Unicode version, and floating point library accuracy are some examples; there are many others). A deserialized copy of a function serialized on a different engine will observationally differ from its original. Given this, I still question the use for defining the concept of a portable function or isPortable.</p>
<p>ARB: Much simpler counterexample to indistinguishability criterion:</p>
<pre><code>let g = <span class="hljs-keyword">function</span> <span class="hljs-title">f</span>() { <span class="hljs-keyword">return</span> <span class="hljs-type">f</span> === g }
</code></pre>
<p>Eval'ing g.toString() cannot create an indistinguishable function.</p>
<p>MF: already in existing spec</p>
<p>ARB: then it's a bug</p>
<p><em>parse tree discussion exploring the idea of replacing function equivalence with parse tree equivalence</em></p>
<p>WH: What exactly is a parse tree? What about whitespace?</p>
<p>DH: White space and comments should be preserved.</p>
<p>YK: No, they shouldn't.</p>
<p>… discussion about parseability, errors, <code>new Function</code> to detect, toSource, etc …</p>
<p>MF: &quot;possible solutions&quot; slide</p>
<a href="#conclusionresolution-functiontostring--functionisportable-mf"><h4 id="conclusionresolution-functiontostring--functionisportable-mf">Conclusion/Resolution</h4></a><ul>
<li>none yet, will continue tomorrow morning, first thing</li>
</ul>

</body>