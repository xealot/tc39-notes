<!doctype html>
<meta charset="utf-8">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.6.0/github-markdown.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github-gist.min.css" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/javascript.min.js"></script>

<title>May 29, 2015 Meeting Notes</title>
<body class="markdown-body">
<a href="#may-29-2015-meeting-notes"><h1 id="may-29-2015-meeting-notes">May 29, 2015 Meeting Notes</h1></a><p>Allen Wirfs-Brock (AWB), John Neumann (JN), Jeff Morrison (JM), Sebastian Markbage (SM), Yehuda Katz (YK), Dave Herman (DH), Sam Tobin-Hochstadt (STH), Kevin Smith (KS), Daniel Ehrenberg (DE), Adam Klein (AK), Jordan Harband (JHD), Jafar Husain (JH), Mark Miller (MM), Michael Ficarra (MF), Chip Morningstar (CM), Simon Kaegi (SK), Peter Jensen (PJ), Eric Farriauolo (EF), Stefan Penner (SP), Paul Leathers (PL), Jonathan Turner (JT), Brendan Eich (BE), Dan Gohman (DG), Mi≈°ko Hevery (MH, Matt Sweeney</p>
<a href="#relaxed-semantics-for-promiseresolve-nominal-check-mm"><h2 id="relaxed-semantics-for-promiseresolve-nominal-check-mm">Relaxed semantics for Promise.resolve nominal check (MM)</h2></a><p>MM: presenting</p>
<pre><code class="language-js"><span class="hljs-built_in">Promise</span>.resolve(arb1).then(arb2, arb3);
</code></pre>
<p>MM: The invariant that we are trying to maintain is that in a realm where the primodials are frozen and arb1, arb2, and arb3 are from an untrusted party, then any code associated with those objects will be executed in a later turn.  Since promises are not frozen, the invariant can be broken if &quot;then&quot; is overridden on the instance.  The invariants can be maintained by a subclass of Promise.</p>
<pre><code class="language-js">DefensiblePromise.resolve(arb1).then(arb2, arb3);
</code></pre>
<p>The other way that the invariant was broken was with Promise.resolve.  Once we added the newTarget parameter to the Reflect.construct method, that meant that someone could invoke the Promise constructor with an arbitrary newTarget.</p>
<p>AWB:  That could be checked in the Promise constructor code.  The constructor could traverse the prototype chain of the constructor.</p>
<p>MM: Because we have the mutability issue we have to protect the invariants in userland anyway, so I like the proposal from C. Scott Ananian.  Just perform a Get on the &quot;constructor&quot; property of the argument supplied to &quot;resolve&quot;.</p>
<p>MM: Do we have species on Promise</p>
<p>AWB:  Yes</p>
<p>MM: Don't think @@species buys you anything here</p>
<p>AWB: But there's a consistency</p>
<p>AK: This is a breaking change for shipping browsers.</p>
<p>YK: I would be suprised if there are programs which rely on this edge case.</p>
<p>MM: We should take this into account.  Even if there's code subclassing promises, they would probably not be affected by this change.  I would like AWB's opinion on whether we use @@species or constructor.</p>
<p>AWB: NewPromiseCapability might use @@species anyway.</p>
<p>KS: Can we confirm?</p>
<p>AWB:  No, it doesn't use @@species.</p>
<p>MM:  In that case I say we use &quot;constructor&quot;.</p>
<p>AWB:  This is a class-side method, @@species is really for instance chaining.</p>
<p>MM:</p>
<pre><code class="language-js">FooCancellable.resolve(arb1).then(arb2).then(arb3);
</code></pre>
<p>@@species of FooCancellable is Cancellable.  Using &quot;constructor&quot;, the first then is called on a FooCancellable and the second is called on a Cancellable.  That looks correct.</p>
<p>AK: We'll have to look and see if this change breaks anything.  (Not asking to postpone.)</p>
<p>SP: Chrome canary is already broken here:</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Promise</span> </span>{}
Foo.resolve(<span class="hljs-built_in">Promise</span>.resolve()).constructor !== Foo;
</code></pre>
<a href="#resolution-relaxed-semantics-for-promiseresolve-nominal-check-mm"><h3 id="resolution-relaxed-semantics-for-promiseresolve-nominal-check-mm">Resolution</h3></a><p>Change Promise.resolve in ES6 specification to use &quot;constructor&quot; property.</p>
<a href="#operator-overloading-breakout"><h3 id="operator-overloading-breakout">Operator overloading breakout</h3></a><p>Slides: <a href="http://www.slideshare.net/BrendanEich/extensible-operators-and-literals-for-javascript">http://www.slideshare.net/BrendanEich/extensible-operators-and-literals-for-javascript</a></p>
<p>DE: Why not use an implicitly named, lexically scoped object for literals (literalSuffixTable)? No staging, just runtime lookup.</p>
<p>BE: Don't overload ===, instanceof, in</p>
<p>DG: Most operators could be useful for SIMD, except == &lt; &lt;= is probably not a good idea since it'll return a SIMD vector which is truthy</p>
<p>BE: Strict equality is still via a structural recursive strict equality check not overloadable, or do we want to change that?</p>
<p>BE: Multimethods for dyadic operaors, not double dispatch; see Christian Hansen's work and Cecil</p>
<p>SM: Maybe mangle the name for literals somehow else?</p>
<p>[Discussion about how to handle suffixes with module imports]</p>
<p>BE: The hope is that the spec just has to define operators and literals in a general way. We can have an intermediate step which is value types.</p>
<a href="#value-types-breakout"><h3 id="value-types-breakout">Value types breakout</h3></a><p>DE reviews Niko Matsakis's proposal <a href="https://github.com/nikomatsakis/typed-objects-explainer/blob/master/valuetypes.md">https://github.com/nikomatsakis/typed-objects-explainer/blob/master/valuetypes.md</a></p>
<ul>
<li>(I missed first implicit bit that DE identified -- /be)</li>
<li>ValueType per-realm registry can only grow, never shrink -- is this ok?</li>
<li>what if a value from another realm lacks a registry entry for its type? type error or implicit registry (MM objected?)</li>
</ul>
<p>SM and DE discussion of trade-offs imposed by registry key as defined by NM</p>
<p>SM concerned about prototype sharing among several value types (immutable array and Array)</p>
<p>DE would rather stick with NM's proposal and leave out prototype-sharing and other such features</p>
<p>DE raises intermediate value representation problem.</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> Point = ValueType(<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'Point'</span>), {<span class="hljs-attr">x</span>: Float32, <span class="hljs-attr">y</span>: Float32});
<span class="hljs-keyword">let</span> p = Point(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
<span class="hljs-comment">// is p.x a Float32 or a JS number?</span>
assert Float32(<span class="hljs-number">0</span>) !== <span class="hljs-number">0</span>;
</code></pre>
<p>Int64 hard case vs. number as well.</p>
<pre><code class="language-js">x = Float32.[[Cast]](<span class="hljs-number">1</span>);
y = Float32.[[Cast]](<span class="hljs-number">2</span>);
</code></pre>
<p>DG: how about Complex?</p>
<p>DE: <code>3+2i</code> is a &quot;literal&quot; that can be partially evaluated by smart implementations; the <code>2i</code> uses literal suffix <code>i</code> to make imaginary-2, and <code>+</code> operator does rest.</p>
<p>In general if number is the intermediate value type, lose precision when demoting (from 64-bits to number) and performance when promoting. Lose-lose!</p>
<p>Could add <code>Float32.add(a, b)</code> and so forth -- and these could be operator multimethods -- to help people avoid promotion to number from 32-bit value types</p>
<p>DE: Also thinking about [[Serialize]] and [[Deserialize]] internal methods (maybe Symbol.serialize and Symbol.deserialize one day) for persistence and structured clone</p>
<p>SM: thinking of separate faster-GC heap for value types since acyclic</p>
<p>DE: thinking about discriminated unions as well, which is why symbols might want to be embedded in value types.</p>
<p>SM: serialization raises question how this value types thinking relates to typed objects</p>
<p>BE: typed objects wanted for their reference identity, heap allocation, mutability</p>
<p>DE: mentions Swift inout handling of structs: <code>p.x = 1</code> =&gt; <code>p = p.replaceX(1)</code> updates whole struct</p>
<a href="#fresh-realms-breakout"><h2 id="fresh-realms-breakout">Fresh realms breakout</h2></a><p>MF: Fresh Realms</p>
<p>Programmer want guarantees about how their program will run without worry about what past scripts have done - in particular referring to scripts like prototype that monkey patch</p>
<p>original proposal....</p>
<p>global-f-global</p>
<pre><code><span class="hljs-keyword">var</span> a=<span class="hljs-number">0</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-string">"realm"</span>;
    a --&gt; refers to lexical scope
}
</code></pre>
<p>new proposal is module based -- want to declare dependencies should be run in a &quot;fresh&quot; realm</p>
<hr>
<p>discussion around how modules might construct graphs and a fine critique of the npm approach.</p>
<p>discussion around the process for splitting an existing module in two in the face of a &quot;fresh&quot; realm and looking at the problems associated with having those newly split modules sharing state</p>
<hr>
<p>DH: Belief is that the dynamic api is sufficient and we need experience before creating declarative syntax</p>
<p>DH: An approach using manifests like System.js to construct the appropriate realm graph</p>
<p>JHD: Want the abilty to run a module in a fresh global especially in the context of using shims</p>
<p>MM: Fine but we should go ahead in parallel e.g. keep the discussion going as we gain experience</p>
<p>MM: SES Provides defensability but not defense. Enables use of multiple co-operative realms while protedting them from one another</p>
<a href="#brendan-break-in-about-literals-and-operator-overloading"><h3 id="brendan-break-in-about-literals-and-operator-overloading">Brendan Break-in about literals and operator overloading</h3></a><p>DH, YK: Do these invariants actually hold? Even if they do, do we really need all of them? Some make sense, but maybe not all.</p>
<p>Christian Plesner Hansen's multimethod post: <a href="https://mail.mozilla.org/pipermail/es-discuss/2009-June/009603.html">https://mail.mozilla.org/pipermail/es-discuss/2009-June/009603.html</a></p>
<p>Christian's language? <a href="http://h14s.p5r.org/2006/05/neptune.html">http://h14s.p5r.org/2006/05/neptune.html</a></p>
<p>YK: For operator overloading, instanceof won't work in Node because Node agressively duplicates prototypes. instanceof is an antipattern.</p>
<p>DH: npm will give you multiple instantiations of the same module.</p>
<a href="#async-await-extensibility"><h2 id="async-await-extensibility">async await extensibility</h2></a><table>
<thead>
<tr><th>sync Iterator:</th></tr>
</thead>
<tbody>
<tr><td>iterator</td></tr>
<tr><td>function*</td></tr>
<tr><td>for (x of xs)</td></tr>
</tbody>
</table>
<table>
<thead>
<tr><th>async iterator</th></tr>
</thead>
<tbody>
<tr><td>AsyncIterator</td></tr>
<tr><td>async function*</td></tr>
<tr><td>async for(x of xs)</td></tr>
</tbody>
</table>
<table>
<thead>
<tr><th>sync observable</th></tr>
</thead>
<tbody>
<tr><td>observable</td></tr>
<tr><td>function*&gt;</td></tr>
<tr><td>for (x on xs)</td></tr>
</tbody>
</table>
<table>
<thead>
<tr><th>async observable</th></tr>
</thead>
<tbody>
<tr><td>Async Observable</td></tr>
<tr><td>async function*&gt;</td></tr>
<tr><td>async for (x on xs)</td></tr>
</tbody>
</table>
<hr>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>*&gt;(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> stream = <span class="hljs-keyword">await</span> someObservable;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> price on stream) {
        <span class="hljs-keyword">yield</span> CAN(price);
    }
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"done"</span>);
    }
}
</code></pre>
<p>vs. (new for* syntax with sugar -- e.g. on</p>
<pre><code class="language-js">push(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> stream = <span class="hljs-keyword">await</span> someObservable;
    <span class="hljs-keyword">for</span>* (<span class="hljs-keyword">let</span> price on stream) { 
        <span class="hljs-keyword">yield</span> CAN(price);
    };
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"done"</span>);
}
</code></pre>
<p>vs. (new for* syntax - desugared)</p>
<pre><code class="language-js">push(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> stream = <span class="hljs-keyword">await</span> someObservable;
    <span class="hljs-keyword">await</span> on(<span class="hljs-keyword">for</span>* (<span class="hljs-keyword">let</span> price <span class="hljs-keyword">of</span> stream) { 
        <span class="hljs-keyword">yield</span> CAN(price);
    });
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"done"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">d</span>(<span class="hljs-params">xs</span>) </span>{
    <span class="hljs-keyword">yield</span> xs[<span class="hljs-number">0</span>];
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">d</span> (<span class="hljs-params">[xs, gen]</span>) </span>{
    gen.next(xs[<span class="hljs-number">0</span>]);
}
</code></pre>

</body>