<!doctype html>
<meta charset="utf-8">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.6.0/github-markdown.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github-gist.min.css" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/javascript.min.js"></script>

<title>July 29, 2015 Meeting Notes</title>
<body class="markdown-body">
<a href="#july-29-2015-meeting-notes"><h1 id="july-29-2015-meeting-notes">July 29, 2015 Meeting Notes</h1></a><p>Allen Wirfs-Brock (AWB), Sebastian Markbage (SM), Jafar Husain (JH), Eric Farriauolo (EF), Caridy Patino (CP), Waldemar Horwat (WH), Istvan Sebastian (IS), Mark Miller (MM), Adam Klein (AK), Michael Ficarra (MF), Peter Jensen (PJ), Domenic Denicola (DD), Jordan Harband (JHD), Jonathan Turner (JT), Paul Leathers (PL), Chip Morningstar (CM), Vladimir Matveev (VM), Ron Buckton (MS), Brian Terlson (BT), Alan Schmitt (AS), Ben Newman (BN), Mohamed Hegazy (MH), Abhijith Chatra (AC), Tom Care (TC), John Neumann  (JN), Dave Herman (DH), Brendan Eich (BE), Daniel Ehrenberg (DE), Dan Gohman (DG), Andreas Rossberg (ARB), Rick Waldron (RW), Mike Pennisi (MP), Akrosh Gandhi (AG), Jonathan Sampson (JS)</p>
<a href="#611-the-scope-of-use-strict-with-respect-to-destructuring-in-parameter-lists"><h2 id="611-the-scope-of-use-strict-with-respect-to-destructuring-in-parameter-lists">6.11 The scope of &quot;use strict&quot; with respect to destructuring in parameter lists</h2></a><p>(Andreas Rossberg, on phone)</p>
<p><a href="https://docs.google.com/presentation/d/1nv4UPDgjL7SdXewTPBt_IpcRxkIFzhz1ENrfyvKcY8Q/">Slides</a></p>
<p>ARB: Strictness Scoping</p>
<p>Issues:</p>
<ul>
<li>VMs need to do parsing &amp; static checks in single pass</li>
<li>w/o building an AST (lazy compilation)</li>
<li>Backtracking is not an option (at least not for V8)</li>
</ul>
<p>DH: clarify backtracking (2 possibilities?)</p>
<p>ARB: rewinding token stream</p>
<p>ARB: easy in ES5 because only additional check is duplicate parameter names</p>
<pre><code class="language-js"><span class="hljs-string">"use sloppy"</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">x, x</span>) </span>{ <span class="hljs-string">"use strict"</span>; }
</code></pre>
<p>Difficult in ES6, b/c default parameters</p>
<pre><code class="language-js"><span class="hljs-string">"use sloppy"</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">g = (o</span>) =&gt; </span>{<span class="hljs-keyword">with</span> (o) {}}) { <span class="hljs-string">"use strict"</span>; }
</code></pre>
<p>ARB: also cannot determine scope due to interactions between Annex B and strict mode:</p>
<pre><code class="language-js"><span class="hljs-string">"use sloppy"</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">g = function(h</span>) </span>{
  { <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">h</span>(<span class="hljs-params"></span>) </span>{} }  <span class="hljs-keyword">return</span> h;
}) {
  <span class="hljs-string">"use strict"</span>;
}
</code></pre>
<p>WH: The issue in this example is hoisting and variable binding, which is more than just error checking. Function h here is nested inside a local block, which means that the 'h' in the return statement refers to different bindings in strict vs. non-strict mode. But you don't know that strict mode is in effect until encountering the 'use strict' later!</p>
<p>DH: Don't know yet whether this is an error until later. Previous examples: Store a &quot;dirty bit&quot;. This example: have to have a data structure that will hoist in 1 of 2 ways if it turns out to be strict mode. Implementable without backtracking.</p>
<p>WH: Note that a single state bit is insufficient. You can have these things nested arbitrarily deep, leading to a potential exponential explosion of states.</p>
<p>ARB:</p>
<p>Much More Difficult in ES6</p>
<ul>
<li>The directive can affect arbitrary code</li>
<li>Nested arbitrarily deep</li>
<li>Would need ot defer any sort of mode-specific decisions in the parser for code that occurs in parameters</li>
<li>But with arrow functions, we do not even know (in time) that we are in a parameter list</li>
</ul>
<pre><code class="language-js"><span class="hljs-string">"use sloppy"</span>;
<span class="hljs-keyword">let</span> f = <span class="hljs-function">(<span class="hljs-params">g = (</span>) =&gt;</span> { <span class="hljs-comment">/* Are we a parameter? Do we have to defer? */</span> <span class="hljs-keyword">with</span> (o) {} }) =&gt; { <span class="hljs-string">"use strict"</span>; }
</code></pre>
<p>ARB:</p>
<p>BE: The arrows are parsed with a cover grammar</p>
<ul>
<li>When initially implementing strict mode, SpiderMonkey had to implement token stream backtracking to account for the function body &quot;use strict&quot; prologue affecting to the left</li>
</ul>
<p>ARB:</p>
<p>Categories of mode specific logic</p>
<ol>
<li>Mode-specifc errors: (eg. with, delete, for-in, octals, let, variable name validity, parameter conflicts)
-&gt; Easy to defer, at least in principle, but may have measurable cost</li>
<li>Special handling of eval (scoping, variable modes)
-&gt; Not an issue</li>
<li>Actual divergence in parsing/scoping (Annex B function scoping, yield?)
-&gt; Affect downstream decisions, transitively defer</li>
</ol>
<p>DH: yield doesn't have contextual differences in strict mode, in generator functions</p>
<p>AWB: restricted in strict mode (non-generator) functions</p>
<ul>
<li>other differences?</li>
</ul>
<p>DH: this-binding</p>
<p>YK: to be clear, these disadvantages only apply to sloppy mode programs; modules and strict mode programs are not affected</p>
<p>ARB: 3 modes, effectively:</p>
<ul>
<li>sloppy</li>
<li>strict</li>
<li>&quot;don't know&quot;</li>
</ul>
<p>DH: (discussing potential for performance regression)</p>
<ul>
<li>Any parenthesis expression could potentially end up in slow mode</li>
</ul>
<p>ARB: Agree</p>
<p>AWB: Don't see this as a problem for JITs</p>
<p>BE: (asks implementors what they're doing to solve)</p>
<ul>
<li>SpiderMonkey uses token stream rewinding and it covers all the cases</li>
</ul>
<p>PL: We haven't gotten this far</p>
<p>ARB: This has been brought up with the team before, and token stream rewinding has been off the table</p>
<ul>
<li>Don't want to do token stream rewinding in V8, various issues (e.g. with Blink interaction?)</li>
</ul>
<p>BE: If it can be done and satisfies performance constraints, then engines should consider</p>
<p>ARB: Compiling functions separately, ie. if function in parameters, compile sep. More than just rewind, would have to record all the functions, may be done with them, may not be done with them</p>
<p>MF: Can we see a proposal/solution?</p>
<p>ARB: Make it an error to have a &quot;use strict&quot; directive in a function with a non-simple parameter list.</p>
<p>YK: Should implement ES6 as written while this is resolved.</p>
<ul>
<li>Don't block implementing default parameters on this</li>
<li>Just a suggestion</li>
</ul>
<p>BE: &quot;more of a guideline than rule&quot;</p>
<p>AWB: You could make the restriction more specific: only disallow functions that declare &quot;use strict&quot; and contain a function in their formals list</p>
<p>ARB: Could be that only error when &quot;use strict&quot; inside function would change the mode, as the outer mode might already be strict</p>
<p>YK: refactoring hazard.</p>
<p>BE: Jason Orendorff says &quot;works for me&quot;</p>
<p>AC: don't like this suggestion, I don't want to impose an error because an implementor couldn't make it work</p>
<p>Discussion, re: hardship of implementation</p>
<p>YK: Don't like that end developers have to know why this won't work, b/c implementing hard.</p>
<p>BE: implementors are considered second to developers</p>
<p>AWB: previously, sloppy mode was restricted to simple parameter lists.</p>
<p>BE: No micro modes: no runtime semantic differences due to</p>
<p>AC: Chakra implements with rewinding</p>
<p>YK: objection: semantically this is the wrong thing</p>
<p>DD: but we're moving to all-strict world, so making the mixed mode cases more painful might be ok</p>
<p>DH: This is such an edge case that I don't tihnk there is an adoption risk.</p>
<ul>
<li>&quot;use strict&quot; retroactively providing subtle differences in the parameter list is a gotcha</li>
<li>preventing diversions in the semantics to close window of confusion</li>
</ul>
<p>BE: Suggestion fixes the right-to-left violation</p>
<p>DH: Could enumerate all those cases and make errors, but much harder.</p>
<ul>
<li>Fixes, but means new rule</li>
</ul>
<p>YK: Poisoning <code>function () { &quot;use strict&quot; }</code></p>
<p>BE: use top level &quot;use strict&quot;</p>
<p>YK: Not realistic</p>
<p>BE: Andreas reduced list to parameter lists that contain:</p>
<ul>
<li>functions</li>
<li>arrows</li>
<li>future &quot;do&quot; expressions</li>
</ul>
<p>Discussion re: &quot;use strict&quot; expectations</p>
<p>YK: Prefer the stricter rule</p>
<p>DH: appear to have consensus on Andreas' solution</p>
<p>AWB: What exactly do we mean by &quot;a function with a 'use strict'; prologue? Are we only talking about &quot;strict transitions&quot; (i.e. functions that declare &quot;use strict&quot; that are in non-strict contexts) or do we mean &quot;use strict&quot; in <em>any</em> functions.</p>
<p>MM: Functions that have a &quot;use strict&quot; know that they are strict, whether they are &quot;pasted&quot; or typed</p>
<ul>
<li>Taking the strict function out of strict context may cause errors as a result of code execution that previously expected strict context, which is a refactoring hazard</li>
</ul>
<p>MP: Another (less difficult/serious) case where strict-function-rewinding is relevant is in the case of named function expressions. e.g.</p>
<pre><code class="language-js">(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">static</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-string">"use strict"</span>; });
</code></pre>
<p>Ref: <a href="https://bugs.ecmascript.org/show_bug.cgi?id=4243">https://bugs.ecmascript.org/show_bug.cgi?id=4243</a></p>
<p>Discussing implemention strategies</p>
<ul>
<li>checking for duplicates</li>
<li>eval, arguments</li>
<li>yield, let</li>
</ul>
<p>BE/AWB: existing semantics imply some right-to-left checking</p>
<p>BE: Non-simple is:</p>
<ul>
<li>default</li>
<li>destructuring</li>
<li>rest</li>
</ul>
<p>(Anything that is <em>not</em> a list of identifiers)</p>
<p>YK: Need to acknowledge that we'll need to tell people to <em>not</em> &quot;use strict&quot; in functions, if they use non-simple parameters.</p>
<p>Acknowledged.</p>
<p>The solution is just use top level &quot;use strict&quot;</p>
<p>DH: We'll fail to explain this at the level of enumerating ES6 features they can or can't use in this case. The outcome is something like &quot;just use top-level strict, or iife strict&quot;</p>
<ul>
<li>Would like to revisit</li>
</ul>
<p>YK: Not just this edge case: ES6 and strict mode has created this weird window.</p>
<p>AK: Functions in the parameter list might become strict if the function is &quot;use strict&quot;</p>
<p>DH: <code>this</code> behaviour changes</p>
<p>YK: Ultimately breaking &quot;use strict&quot; for function</p>
<p>AWB: Any function whose mode (lost track)</p>
<p>Discussion about ES6 feature adoption.</p>
<p>RW: disagreed with error when &quot;use strict&quot; occurs locally, but outer mode is already strict (ie. no mode change)</p>
<p>Discussion about developer expectation.</p>
<p>AWB: there is another alternative spec function that is more restrictive: ContainsExpression</p>
<p>RW demures (&quot;You might say I am not willing to die on this hill.&quot;)</p>
<a href="#conclusionresolution-611-the-scope-of-use-strict-with-respect-to-destructuring-in-parameter-lists"><h4 id="conclusionresolution-611-the-scope-of-use-strict-with-respect-to-destructuring-in-parameter-lists">Conclusion/Resolution</h4></a><ul>
<li>Make it an error to have a &quot;use strict&quot; directive in a function with a non-simple parameter list.</li>
<li>Early error</li>
<li>No matter what mode you were already in</li>
<li>When people want to use local &quot;use strict&quot;, doing it b/c they want to know that this is always strict, no matter where it ends up.
<ul>
<li>Applies to all kinds of function/generator syntax</li>
</ul></li>
<li>IsSimpleParameterList <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-function-definitions-static-semantics-issimpleparameterlist">http://www.ecma-international.org/ecma-262/6.0/#sec-function-definitions-static-semantics-issimpleparameterlist</a></li>
</ul>
<a href="#69-reconsidering-the-numberprototype-as-an-ordinary-object-change"><h2 id="69-reconsidering-the-numberprototype-as-an-ordinary-object-change">6.9 Reconsidering the Number.prototype-as-an-ordinary-object change</h2></a><p>(Daniel Ehrenberg)</p>
<p>DE: This change breaks the web (specifically: mootools calls <code>Number.prototype.valueOf(Number.prototype)</code>)</p>
<p><a href="https://esdiscuss.org/topic/number-prototype-not-being-an-instance-breaks-the-web-too">https://esdiscuss.org/topic/number-prototype-not-being-an-instance-breaks-the-web-too</a>
<a href="https://github.com/mootools/mootools-core/issues/2711">https://github.com/mootools/mootools-core/issues/2711</a></p>
<p>Solution: roll back the change.</p>
<p>BE: Number, String, Boolean should be</p>
<p>MM: To be clear: Date.prototype will be an object, not Date; RegExp.protototype will be an object, not RegExp. Every built-in constructor introduced after ES5 will have a plain object prototype.</p>
<p>MM: Prefer we do Number, Boolean, String together</p>
<a href="#conclusionresolution-69-reconsidering-the-numberprototype-as-an-ordinary-object-change"><h4 id="conclusionresolution-69-reconsidering-the-numberprototype-as-an-ordinary-object-change">Conclusion/Resolution</h4></a><ul>
<li>Boolean.prototype, Number.prototype, String.prototype rolled back</li>
<li>File a spec bug?</li>
</ul>
<a href="#612-spec-defacto-stringprototypetrimlefttrimright"><h2 id="612-spec-defacto-stringprototypetrimlefttrimright">6.12 Spec defacto String.prototype.trimLeft/trimRight</h2></a><p>(Sebastian Markbage)</p>
<p><a href="https://github.com/sebmarkbage/ecmascript-string-left-right-trim">https://github.com/sebmarkbage/ecmascript-string-left-right-trim</a></p>
<p>SM: Already shipping in all major engines. Controversy: what to call it?</p>
<p>JHD: in JavaScript, left-to-rightness of strings is a rendering artifact. The conceptual &quot;first&quot; character of any string, whether LTR or RTL, is index 0, and the &quot;last&quot; is index length minus 1. Thus, in JS, left/start/index zero are the same, and right/end/index length minus one are the same.</p>
<p>DH: These are extremely common in programming languages</p>
<p>Discussing semantics of &quot;left&quot;, &quot;right&quot; and &quot;start&quot;, &quot;end&quot;</p>
<p>DH: There is precedence for JavaScript interpreting the word &quot;right&quot; to mean &quot;the end of a sequence&quot;, from ES5: <code>Array.prototype.reduceRight</code></p>
<a href="#conclusionresolution-612-spec-defacto-stringprototypetrimlefttrimright"><h4 id="conclusionresolution-612-spec-defacto-stringprototypetrimlefttrimright">Conclusion/Resolution</h4></a><ul>
<li>Approved for Stage 1?</li>
</ul>
<a href="#revisit-611-the-scope-of-use-strict-with-respect-to-destructuring-in-parameter-lists"><h2 id="revisit-611-the-scope-of-use-strict-with-respect-to-destructuring-in-parameter-lists">REVISIT: 6.11 The scope of &quot;use strict&quot; with respect to destructuring in parameter lists</h2></a><p>DH: The only thing that &quot;use strict&quot; can cause (in ES5) is an error (to the left)</p>
<ul>
<li>Our resolution was to say, &quot;the use strict prologue in functions is now defunct&quot;</li>
<li>An alternative, w/ better outcome: revise &quot;use strict&quot; to no longer affect <em>anything</em> to the left.</li>
<li>A back-compat change, because it only allows things that were previously disallowed.</li>
<li>no semantic difference</li>
</ul>
<p>AWB: There are implementation semantics, w/r to parameters</p>
<ul>
<li>extra scope contour for eval context</li>
<li>duplicate parameters</li>
</ul>
<p>WH: How does it affect hoisting checks?</p>
<p>AWB: Hoisting rules in annex b don't apply if there is decl of same name (need to double check)</p>
<p>MM: How did we resolve names introduced in the function head vs names introduced in the function body, w/r let/const</p>
<p>AWB: disallowed</p>
<p>Discussion, re: strict in blocks?</p>
<p>AWB: need to check this against the existing function declaration instantiation, re: strict/non-strict checks</p>
<p>STH: Expressions in parameter list are not in strict mode.</p>
<ul>
<li>Enter strict mode due to prologue at beginning of function, does put parameter list expressions in strict mode</li>
</ul>
<p>YK: Bigger picture: ES5 introduced the concept of a strict function.</p>
<ul>
<li>The proposal before is honest about admitting that's not a thing</li>
<li>Sam's proposal ignores that and introduce's a new thing</li>
</ul>
<p>Discussion, re: expectations of strict mode in functions</p>
<p>AWB: parameter with an initializer that uses <code>this</code></p>
<ul>
<li>Assuming that's called with nothing in that position, what is <code>this</code>?</li>
<li>If strict, <code>this</code> is undefined</li>
<li>If sloppy, <code>this</code> is global object</li>
</ul>
<pre><code class="language-js"><span class="hljs-string">"use sloppy"</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">foo = this</span>) </span>{
<span class="hljs-meta">  "use strict"</span>;
  <span class="hljs-keyword">return</span> foo;
}
f(); 
<span class="hljs-comment">// what is the value of this expression? the global object? or `undefined`?</span>
<span class="hljs-comment">// w/r to Sam's proposal (eliminating right-to-left strict-ness effect)</span>
</code></pre>
<p>YK:</p>
<p>With Sam's proposa, this would return <code>[undefined, Global]</code>, despite expecting <code>[undefined, undefined]</code></p>
<pre><code class="language-js">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">foo = this</span>) </span>{
<span class="hljs-meta">  "use strict"</span>;
  <span class="hljs-keyword">return</span> [<span class="hljs-keyword">this</span>, foo];
})();
</code></pre>
<p>DH: In ES5, there was a fundamental confusion about &quot;use strict&quot; in functions. This was exacerbated by ES6. In the fullness of time, TC39 is saying, the directive prologue should be used:</p>
<ul>
<li>Global &quot;use strict&quot; (being careful of script concatenation)</li>
<li>Top-level IIFE &quot;use strict&quot;</li>
<li>module code</li>
</ul>
<p>MM: We should be explicit w/r to &quot;top level strict mode&quot;, in that we actually mean &quot;top level iife with strict mode&quot;—to avoid the concatenation problem.</p>
<p>Advice: &quot;Just use modules&quot;.</p>
<a href="#conclusionresolution-revisit-611-the-scope-of-use-strict-with-respect-to-destructuring-in-parameter-lists"><h4 id="conclusionresolution-revisit-611-the-scope-of-use-strict-with-respect-to-destructuring-in-parameter-lists">Conclusion/Resolution</h4></a><ul>
<li>The previous consensus remains</li>
</ul>
<a href="#revisit-67-new--generatorfunction"><h2 id="revisit-67-new--generatorfunction">REVISIT: 6.7 new &amp; GeneratorFunction</h2></a><p>AWB: (answers to questions from yesterday)</p>
<ul>
<li>Generator functions are new-able</li>
<li>Generator methods are new-able</li>
<li>Implicit body</li>
</ul>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">g</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">this</span>.foo }

x = {
  *f() { <span class="hljs-keyword">this</span>.foo }    
};

<span class="hljs-keyword">new</span> f(); <span class="hljs-comment">// ok</span>
<span class="hljs-keyword">new</span> x.f(); <span class="hljs-comment">// ok</span>
</code></pre>
<p>Relevant SpiderMonkey bug: <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1166950">https://bugzilla.mozilla.org/show_bug.cgi?id=1166950</a></p>
<p>DH: Bare generator function call behaviour is correct?</p>
<p>AWB: Confirm</p>
<p>Updated:</p>
<table>
<thead>
<tr><th>S</th><th>I</th><th>Code</th></tr>
</thead>
<tbody>
<tr><td>X</td><td>X</td><td><code>{ *foo() {} }</code> (no [[construct]])</td></tr>
<tr><td>X</td><td>X</td><td><code>function * () {}</code> (no [[construct]])</td></tr>
<tr><td>?</td><td>?</td><td><code>function * () { this }</code> is exactly like <code>function() { this }</code></td></tr>
</tbody>
</table>
<p>AWB: Concern about removing new:</p>
<ul>
<li>Implemented to allow it without throwing</li>
<li>No TDZ on <code>this</code></li>
</ul>
<p>Acceptable risk?</p>
<p>BT: Implementors on both V8 and SpiderMonkey have shown interest in making generator not newable</p>
<a href="#conclusionresolution-revisit-67-new--generatorfunction"><h4 id="conclusionresolution-revisit-67-new--generatorfunction">Conclusion/Resolution</h4></a><ul>
<li>Spec change: generator functions and methods do not have a [[construct]] trap, so <code>new</code> throws</li>
</ul>
<a href="#process-document-discussion-to-settle-things-once-and-for-all"><h2 id="process-document-discussion-to-settle-things-once-and-for-all">Process Document discussion (to settle things once and for all)</h2></a><p>(Domenic Denicola)</p>
<p>DD: (Showing <a href="https://tc39.github.io/process-document/">https://tc39.github.io/process-document/</a>)</p>
<p>Reviewed:</p>
<ul>
<li><a href="https://github.com/tc39/process-document/pull/1/">https://github.com/tc39/process-document/pull/1/</a></li>
<li><a href="https://github.com/tc39/process-document/pull/2/">https://github.com/tc39/process-document/pull/2/</a></li>
</ul>
<p>AWB: w/r to reviewers, committee should assign reviewers.</p>
<p>DD/RW: reviewers attached at Stage 1. Stage 2 entrance requires review</p>
<p>RW: Propose: At Stage 0, reviewers get &quot;attached&quot;, but non-binding. (basically, it's a &quot;champion group&quot;)</p>
<p>... Next thing...</p>
<a href="#what-is-an-implementation"><h2 id="what-is-an-implementation">What is an &quot;implementation&quot;?</h2></a><p>Discussion re: Stage 4</p>
<ul>
<li>Important to get feedback from engaged implementors</li>
</ul>
<p>RW: Concerns about flag/no flag</p>
<p>DD: Must be unflagged</p>
<p>RW: Disagree, will result in stonewalling from implementors</p>
<p>DH: Transpilers should count</p>
<p>Discussion, re: experiences had with other new features.</p>
<p>&quot;Significant in-the-field experience with shipping implementations, such as that provided by independent VMs&quot;</p>
<p>Stage 3: &quot;Will require feedback from implementations and users&quot;</p>
<a href="#conclusionresolution-what-is-an-implementation"><h4 id="conclusionresolution-what-is-an-implementation">Conclusion/Resolution</h4></a><ul>
<li>need links to Domenic's commits</li>
</ul>
<a href="#68-simdjs-start-the-process-to-move-towards-stage-3"><h2 id="68-simdjs-start-the-process-to-move-towards-stage-3">6.8 SIMD.js: Start the process to move towards Stage 3</h2></a><p>(Dan Gohman, John Mccutchan, Peter Jensen, Daniel Ehrenberg)</p>
<p><a href="simd.pdf">Slides</a></p>
<p>DE: (introducing topic)</p>
<ul>
<li>Boolean vectors
Previously, the result of SIMD.Float32x4.greaterThan was a SIMD.Int32x4 vector, with -1/0 for true/false
Now, new boolean vector types, e.g. SIMD.Bool32x4, represent boolean results and values
Used for select and logic operations
More efficiently implementable on some architectures
Not simply Boolx4 because the registers in implementations may be represented differently based on width.</li>
</ul>
<ul>
<li>Unsigned operations</li>
</ul>
<p>Unsigned comparisons
Unsigned saturating add/sub
Unsigned extractLane
No changes needed for constructor, replaceLane because coercion will wrap unsigned values to the appropriate signed value
No separate unsigned type</p>
<ul>
<li>Postponed features</li>
</ul>
<p>Float64x2--we couldn’t find an important use case with improved performance
Int64x2--Not needed due to boolean vectors, and really not needed because Float64x2 is out
selectBits--minimal utility due to select, and efficiently implementable in terms of other boolean operations</p>
<ul>
<li>sumOfAbsoluteDifferences replacement</li>
</ul>
<p>widenedAbsoluteDifference, unsignedHorizontalSum, absoluteDifference
Seeking implementation feedback: applications and benchmarks
Replaces sumOfAbsoluteDifferences (slow on ARM)</p>
<ul>
<li>Other spec changes</li>
</ul>
<p>Homoiconic toString()
<code>SIMD.Float32x4(1, 2, 3, 4).toString()</code> =&gt; <code>&quot;SIMD.Float32x4(1, 2, 3, 4)&quot;</code>
Shift operations max out at 0/-1, rather than wrapping around
Ops like reciprocalApproximation are loosely specified, like Math.sin
Removed operations on DataView--TypedArray ops suffice
Operations on subnormals may flush to 0, unlike ES scalars
Various minor spec bug fixes</p>
<p>AWB: w/r toString. The approach shown is a new precedent</p>
<p>DD: Similar to Symbol</p>
<p>AWB: Will this be the new way</p>
<p>BE: value types with literal form should convert, but this isn't value types. I like it.</p>
<p>AWB: Should other new things have this toString() output? Map &amp; Set?</p>
<p>(moving on)</p>
<ul>
<li>Strong type checks on lanes</li>
</ul>
<p>Lanes are required to be Int32s and not implicitly coerced</p>
<p>(See 5.1.2, <a href="http://littledan.github.io/simd.html">http://littledan.github.io/simd.html</a> )</p>
<p>AWB: for WebIDL, we advised to use normal ES coercions</p>
<p>DE: Considered specified getX, getY, etc.</p>
<p>DH: I don't know if it's that important to coerce or check.</p>
<p>BE: Doesn't want this to be an enumerated type. Symbols?</p>
<p>AWB: The advantage is that Symbol is not coercible and you only accept those that you've defined.</p>
<p>DE: if we had a Symbol API, we'd still want an extract lane API</p>
<p>STH: numbers are the right thing here</p>
<p>AWB: ToNumber, because that's what ES does</p>
<ul>
<li>Actually ToInteger</li>
<li>ToLength</li>
</ul>
<p>WH: Note that the proposal is a bit inconsistent in validating numeric inputs. For example, shifts use ToUint32 for the shift count, which turns -1 into a huge shift amount. ECMAScript's built-in shifts treat the shift amount mod 32, while the proposed ones treat it mod 2^32.</p>
<p>DE:</p>
<ul>
<li>load and store operating on any TypedArrays</li>
</ul>
<p>load and store take TypedArrays as arguments and permit array element type mismatch with SIMD type</p>
<p>WH: Reading spec, cannot load and store booleans. Looks intentional.</p>
<p>DE: Fails on booleans, intentionally.</p>
<ul>
<li>Intentionally abstract data type</li>
<li>Want concrete data type, call select</li>
</ul>
<p>WH: Fix other places in the spec for booleans, such as the statement that bitwise cast can cast any SIMD type into another SIMD type.</p>
<p>AWB: (requests justification for extracting values of a different type than the type of the Typed Array)</p>
<p>DE: DataView doesn't really work, in an asm context. Operations on DataView accept endianness where this has to use native endianness to be efficient</p>
<p>AWB: if int8 array, extracting floar 64, does it</p>
<p>DE: No, it is element-aligned. The hardware supports this.</p>
<p>DG: (phone) confirms hardware support</p>
<p>AWB: If you're talking about a float32array and you're extracting int16's, that just seems like a type error.</p>
<p>DE: Better?</p>
<p>DH: Go back and change array buffer, can't do that</p>
<ul>
<li>ArrayBuffer was defined as opaque</li>
<li>Everyone wants to change rthat now</li>
<li>No real world constraint</li>
</ul>
<p>DE: how is opacity enforced?</p>
<p>(no answer yet)</p>
<p>WH: Some ArrayBuffers are indeed opaque. Restricted exposure for security reason</p>
<p>DH: TypedArray views on ArrayBuffer, detached</p>
<ul>
<li>Allow operation on ArrayBuffer</li>
<li>We'll have to break the invariant</li>
</ul>
<p>BE/DH: what they're doing will work</p>
<p>WH: Not a pointless invariant. Move on.</p>
<p>(moved on)</p>
<p>Questions for Committee</p>
<ul>
<li>Should wrapper constructors be explicitly [[Construct]]-able, like Number, or not, like Symbol?</li>
</ul>
<p>BE: have to call with new to get the object</p>
<p>AWB: Symbol is just odd because concern that <code>new Symbol()</code> would be used to get a generative object.</p>
<p>DD: Necessary to impose a rule for creating a Symbol</p>
<ul>
<li>No literal form? No wrapper</li>
</ul>
<p>DE: if you call construct, if NewTarget undefined, construct wrapper</p>
<p>AWB: Minimize new patterns. Overloading constructor is not new.</p>
<p>AK: Why this route instead of Symbol route?</p>
<p>DE: Symbol is special throwing on new? But maybe Symbol is the new way</p>
<p>DD: If no literal, then no <code>new</code>. If a literal is added later, then re-open <code>new</code></p>
<p>BE: (explains wrapper history, aggree with DD)</p>
<p>(moving on)</p>
<p>Spec Language Innovation Acceptable?</p>
<ul>
<li>Rest parameters</li>
<li>SIMD as a spec meta-variable</li>
</ul>
<p>AWB: There was use of rest early in ES6, but taken out</p>
<p>BE: parameters that were optional</p>
<p>AWB: implies JS level parameter list</p>
<p>DE: no</p>
<p>Discussion, re: spec mechanisms</p>
<p>(moving on)</p>
<p>RW: Recommend moving this to a separate spec, similar to Intl (Ecma-402). (Note that this was considered ideal by the champions as well, despite the opposition from other members).</p>
<p>DH: disagrees</p>
<p>WH: Also disagrees with separate spec. This defines primitives tightly bound into the core of ES, with serious interactions and precedence-setting with other ES work such as value types.</p>
<p>DE: Issues surrounding value type definitions, but don't want to to wait for value types. Don't want to be blocked and separate spec ensures that</p>
<p>(moving on to implementation status)</p>
<p>Firefox Implementation Status</p>
<p>In Firefox nightly:</p>
<ul>
<li>Float32x4 and Int32x4 entirely implemented and optimized in JavaScript (regular and asm.js) on x86 and x64.</li>
<li>Missing boolean vectors</li>
<li>Other SIMD types (Int16x8, Int8x16, Float64x2) partially implemented in the interpreter only (ergo not optimized). The newer APIs (SAD) haven't been implemented yet.</li>
<li>All SIMD types are implemented as value objects, at the moment.</li>
</ul>
<p>Microsoft Edge Implementation Status</p>
<ul>
<li>Majority of SIMD.<em>.</em> APIS supported.</li>
<li>Some of the new APIS need to be implemented such as ExtractLane and ReplaceLane, and unsigned operations</li>
<li>Asm.js optimization is complete (minus new api support).</li>
<li>Non-asm.js optimization we plan to start soon.</li>
</ul>
<p>V8 Implementation Status</p>
<ul>
<li>Intel object implementation will not be used for V8 and work has started to implement value types from scratch. Intel code generation may be rewritten to the new model.</li>
<li>Bill Budge has added a Float32x4 type with correct value semantics and basic operations, without acceleration, behind a flag.</li>
</ul>
<p>Specification Status</p>
<ul>
<li>SIMD.js Specification v0.7.2</li>
<li>Updated polyfill and tests validate all operations, basic value semantics</li>
<li>SIMD.js is ready for reviewers and and editor comments/signoff</li>
<li>Hope to move to Stage 3 in the September meeting</li>
</ul>
<p>Requesting reviewers</p>
<p>WH: purpose of spec, disagreement whether to support only use cases experienced or useful with a more ecmascripty orthogonal feel. For example, the spec currently can load int8, uint8, int16, uint16, int32, uint32, but it can only extract the first five of them (can't extract uint32 even though can extract int32 or uint16). Min and max work on floats but not on integers, even though there is no hardware obstacle to do so and even though there are much more complex intrinsics defined such as
unsignedAbsoluteDifference.</p>
<p>DE: support unsigned operations on int16 and int8</p>
<p>BE: waldemar wants max on integers that can</p>
<p>DH: SIMD building clear layer to hardware</p>
<p>WH: want consistency:</p>
<ul>
<li>integer max</li>
<li>uint32</li>
<li>for usability, uint8 SIMD pixel values printing liked TypedArrays as 255,255,0 instead of -1,-1,0.</li>
</ul>
<p>WH: Diverged from TypedArray,</p>
<p>AWB: TypedArray both have int32 and uint32, JS programmer expects that</p>
<p>BE: argument to be consistent</p>
<p>DE: TypedArray is the model going forward, with the exception of Uint8ClampedArray</p>
<p>AWB/BE: Yes</p>
<p>WH: treatment of denorms non-deterministic</p>
<p>DE:</p>
<ul>
<li>operation and flush to 0</li>
<li>operation only</li>
</ul>
<p>WH: Does the hardware flush both inputs and outputs to 0, or is there some major hardware that flashes only inputs or only outputs to zero? (an arithmetic operation might take denorms as inputs, or it could produce a denorm output even though all inputs are norms)</p>
<p>DE: Both inputs and outputs</p>
<p>WH: [later in the discussion] Intel has FTZ and DAZ bits which control these separately, so they can be independent.</p>
<p>(Difference between Arm and Intel)</p>
<p>DG: Arm 64, arm v8 corrects this</p>
<p>MM: this non-determinism is actually just difference between platform</p>
<p>WH: The SIMD spec doesn't state that. It could differ operation-by-operation.</p>
<p>DE: The spec can't state that.</p>
<p>WH: Really? Why?</p>
<p>Discussion re: nan encoding</p>
<p>DE: <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-setvalueinbuffer">http://www.ecma-international.org/ecma-262/6.0/#sec-setvalueinbuffer</a> (step 9.a)</p>
<p>AWB: (explaining why spec says this)</p>
<p>DH: we should change the def of SameValueZero to say that two different bit patterns for a NaN are not equivalent</p>
<p>DE: create a data property and set value to one bit pattern, non-writable, non-configurable, call Object.defineProperty with a different NaN, then do [[Get]] and you'll receive old bit pattern</p>
<p>DH: No mutation, but incorrectly states that change was successful</p>
<p>DE: spec says a platform will have one endianess or the other; this can be applied to denorms. Spec dependent.</p>
<p>WH: What do relational operations (.equal, .lessThan, etc.) do when they see a denorm? treat as zero?</p>
<p>DG: treat as zero</p>
<p>WH: So then what will === do? Do they equate all distinct denorms to zero (which would be really weird as ES behavior)? Are you going for the fast implementation of === or the precise implementation?</p>
<p>DG: === does not equate denorms to zero, even on platforms that flush denorms. It can be slower than .equal.</p>
<p><a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4610935">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4610935</a></p>
<p>DE: One outstanding question was whether this work should be done in a separate specification.</p>
<p>RW: Yes, I had suggested that. But you said something about a polyfill for SIMD.js?</p>
<p>DE: It is incomplete</p>
<p>BE: It can't express value object; it can't intercept <code>==</code> or <code>===</code></p>
<p>RW: Alright, then it is no longer a suggestion of mine</p>
<p>Unsigned Types? Argument for them?</p>
<p>Consistency with TypedArray</p>
<p>DH: I want to know more about what SIMD use cases are, operations should map to need</p>
<p>WH: want unsigned types:</p>
<ul>
<li>consistency with typed array</li>
<li>printing (want 255, not -1)</li>
</ul>
<p>(not an explosion of the API)</p>
<p>DE: fewer function names, more function objects.</p>
<p>AWB: lot's of domains with similar conventions</p>
<ul>
<li>once integrated, it becomes part of the spec as a whole and will require understanding of these irregularities</li>
<li>an argument <em>for</em> separate spec</li>
</ul>
<p>DE: it's a large thing, mostly irreducible</p>
<p>JHD: non-specialists are going to write this stuff by hand.</p>
<p>(Argument to make the API more like JS)</p>
<p>DE: prefer to keep it as is</p>
<p>YK: So a specialist doesn't need the unsigned types?</p>
<ul>
<li>then don't worry about use by non-specialists</li>
</ul>
<p>DH: Either accept Waldemar's argument, or state case based on historical precedence. If no consistency, then don't care.</p>
<p>WH: Note that I'm not alone with that argument. I don't want this to become personal.</p>
<a href="#conclusionresolution-68-simdjs-start-the-process-to-move-towards-stage-3"><h4 id="conclusionresolution-68-simdjs-start-the-process-to-move-towards-stage-3">Conclusion/Resolution</h4></a><ul>
<li><code>new</code> throws</li>
<li>not separate spec</li>
<li>spec mechansisms: Allen, Brian, Rick and Dan to work through</li>
<li>Reviewers:
<ul>
<li>Waldemar Horwat</li>
<li>Jordan Harband</li>
<li>Brendan Eich</li>
<li>Mark Miller</li>
</ul></li>
</ul>

</body>