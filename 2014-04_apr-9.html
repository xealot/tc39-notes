<!doctype html>
<meta charset="utf-8">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.6.0/github-markdown.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github-gist.min.css" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/javascript.min.js"></script>

<title>April 9, 2014 Meeting Notes</title>
<body class="markdown-body">
<a href="#april-9-2014-meeting-notes"><h1 id="april-9-2014-meeting-notes">April 9, 2014 Meeting Notes</h1></a><p>Doug Crockford (DC), Brian Terleson (BT), Luke Hoban (LH), Dmitry Lomov (DL), Waldemar Horwat (WH), Allen Wirfs-Brock (AWB), John Neumann (JN), Rick Hudson (RH), Rick Waldron (RW), Eric Ferraiuolo (EF), Jafar Husain (JH), Jeff Morrison (JM), Seo-Young Hwang (SYH), Mark Honenberg (MH), Caridy Patino (CP), Yehuda Katz (YK), Niko Matsakis (NM), Ben Newman (BN), Filip Pizlo (FP), Norbert Lindenberg (NL), Sebastian Markbage (SM), Mathias Bynens (MB), Rafael Weinstein (RWS), Jaswanth Sreeram (JS), Alex Russell (AR), Istvan Sebestyen (IS), Mark Miller (MM), Tatiana Shpeisman (TS), Brandon Benvie (BB), Brendan Eich (BE)</p>
<a href="#rf-status"><h2 id="rf-status">RF Status</h2></a><p>(John Neumann)</p>
<p>The May version of the specification is the opt-out version</p>
<p>See:
<a href="http://www.ecma-international.org/memento/TC39%20policy/Ecma%20Experimental%20TC39%20Royalty-Free%20Patent%20Policy.pdf">http://www.ecma-international.org/memento/TC39%20policy/Ecma%20Experimental%20TC39%20Royalty-Free%20Patent%20Policy.pdf</a> (E.4-E.6)
<a href="http://www.ecma-international.org/memento/TC39%20policy/Opt%20Out%20Form%20for%20a%20TC39%20Royalty%20Free%20%28RF%29%20Task%20Group%20%28TG%29.pdf">http://www.ecma-international.org/memento/TC39%20policy/Opt%20Out%20Form%20for%20a%20TC39%20Royalty%20Free%20%28RF%29%20Task%20Group%20%28TG%29.pdf</a></p>
<a href="#conclusionresolution-rf-status"><h4 id="conclusionresolution-rf-status">Conclusion/Resolution</h4></a><ul>
<li>May document will be opt-out</li>
</ul>
<a href="#rftg-item"><h2 id="rftg-item">RF/TG Item</h2></a><p>(John Neumann)</p>
<p>JN: Vote to request lifetime membership waiver for Brendan Eich</p>
<p>Motion to approve? [WH raises motion]
Yes, seconded</p>
<p>No discussion, No objection</p>
<a href="#conclusionresolution-rftg-item"><h4 id="conclusionresolution-rftg-item">Conclusion/Resolution</h4></a><ul>
<li>unanimously in favor</li>
</ul>
<a href="#objectobserve-update"><h2 id="objectobserve-update">Object.observe Update</h2></a><p>(Rafael Weinstein)</p>
<p>RWS: The next step was spec text review.</p>
<p>YK: Reviewed but have feedback</p>
<p>AWB: Concerned not enough attention from committee members</p>
<p>YK: Similar concern, but additionally want to see more practical application testing of new features in general.</p>
<p>AR: Can you be more concrete, with regard to Object.observe</p>
<p>YK: There is a need for filtering of change records</p>
<p>RWS: We had hoped to work on this post 1.0</p>
<p>YK: We tried this and it's messy and complicated, so it's either a matter of being messy and complicated in user code or in V8</p>
<p>LH: Valid and being addressed... How does this correlate to the status of the spec.</p>
<p>YK: The spec seems fine, but this is an issue discovered when I tried to make something with it.</p>
<p>LH: More effort has gone into review of this feature than any other</p>
<p>YK: But needs to be useful to library code.</p>
<p>AWB: (continuing) I'd feel more confident if more committee members reviewed the spec for correctness.</p>
<p>RWS: What is the purpose of the reviewer role, in this stage? I assumed it was for the mechanics, not the feature itself. I'm confident we can work through the existing concerns.</p>
<p>YK: I think that practitioners need to be given an opportunity to review in real use</p>
<p>RWS: This should be done much earlier in the process.</p>
<p>JH: How long is needed to feel comfortable with this?</p>
<p>YK: We already made implementation attempts and ultimately view them as failures. We wrote real code and discovered real problems.</p>
<p>LH: So you're not comfortable giving consensus at this point, based on your actual experience.
...Concern that consensus blocking this late</p>
<p>RWS: Propose that we don't move to stage 3, but I want a commitment from Yehuda that to prioritize working through the remaining issues.</p>
<p>YK: Confirm</p>
<p>RWS: We should view this as feedback for the new process</p>
<p>YK: There was feedback, but no action</p>
<p>RWS: There have been many updates and if there were issues, that was on you to follow up... If there is criticism, it needs to be on record.</p>
<p>AWB: In addition to meeting notes record, file bugs to track progress</p>
<p>YK: In general, if there are concerns, there’s two sides: person A thinks “I should push harder” vs. person B saying “that’s fine” without giving it much thought</p>
<p>AWB: Still need to be more active reviewing in the committee.</p>
<p>Relevant: <a href="https://github.com/rwaldron/tc39-notes/blob/master/es6/2013-09/sept-19.md#7-objectobserve-status-report">https://github.com/rwaldron/tc39-notes/blob/master/es6/2013-09/sept-19.md#7-objectobserve-status-report</a> (incomplete notes about the
discussion about filtering in general)</p>
<a href="#conclusionresolution-objectobserve-update"><h4 id="conclusionresolution-objectobserve-update">Conclusion/Resolution</h4></a><ul>
<li>RWS withdrawing request for stage 3</li>
<li>YK commits to prioritize working through remaining issues prior to next meeting.</li>
<li>RW commits to reviewing for spec mechanics</li>
<li>AWB: “Don’t approve stuff without reading the spec text, dammit” :)</li>
</ul>
<p>(Istvan Sebestyen joins remotely)</p>
<a href="#rf-status"><h2 id="rf-status">RF Status</h2></a><p>JN: (recaps decisions)</p>
<p>IS: Issues:</p>
<ol>
<li>Status of Third Party contribution</li>
</ol>
<ul>
<li>Currently under ballot</li>
<li>expect it to pass</li>
</ul>
<p>AWB: Will the forms be available prior to the conclusion of the ballot?</p>
<p>IS: Yes, will make available as soon as we can.</p>
<p>AWB: We have a back log of contributions waiting to be accepted. Would like to be able to provide immediate instruction</p>
<ol start="2">
<li>IPR has prepared FAQ addressing Ecma copyright policy</li>
</ol>
<ul>
<li><a href="http://www.ecma-international.org/memento/Ecma%20copyright%20FAQ.htm">http://www.ecma-international.org/memento/Ecma%20copyright%20FAQ.htm</a></li>
</ul>
<ol start="3">
<li><p>Liason with IETF</p></li>
<li><p>JSON</p></li>
</ol>
<p>AWB: The first edition is done, no sign of interest for a second edition.</p>
<p>IS: Fast track ISO?</p>
<p>(will follow up)</p>
<p>RW: Istvan, please send link to FAQ for inclusion.</p>
<p>confirmed</p>
<p>BT: CLA needs to be electronic and checked automatically for each pull request (bot)</p>
<p>RW: Needs to provide access to committee members to confirm contributor agreement.</p>
<p>EF: Is the vote for just the forms/agreements?</p>
<p>AWB: The vote is to approve the policy, the forms already exist.</p>
<a href="#conclusionresolution-rf-status"><h4 id="conclusionresolution-rf-status">Conclusion/Resolution</h4></a><ul>
<li>RW/BT/AWB to send CLA requirements (noted above) as need to be successful</li>
</ul>
<a href="#parallel-js-spec-report"><h2 id="parallel-js-spec-report">Parallel JS Spec Report</h2></a><p>(Rick Hudson)</p>
<p>Slides: <a href="https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-04/TC39PJSApril2013.pdf">TC39PJSApril2013.pdf</a></p>
<p>RH:
Summary</p>
<ul>
<li>Major Focus on implementation</li>
<li>Use case driven perf tuning</li>
<li>Harvey Mudd collab</li>
<li>Prohect implementing OpenCV</li>
<li>Demos rewritten to use typed object API</li>
</ul>
<p>Design Goals</p>
<ul>
<li>Ease of use</li>
<li>Deterministic where  possible</li>
<li>Follow current syntac seantics, and security</li>
</ul>
<p>Platorm Independent</p>
<ul>
<li>Supporte all kinds of Platforms, Parallel or not</li>
<li>Perform well on different parallel architectures, multi-core, GPUs SIMD</li>
</ul>
<p>Extracting reasonable performance out of parallet hardware</p>
<ul>
<li>Extracting all performance a secondary goal</li>
</ul>
<p>Key Insight: Temporal Immutability</p>
<ul>
<li>During Concurrent Execution</li>
<li>A computation can read or write its local data</li>
<li>A computation can read shared state</li>
<li>Parent waits patientily</li>
<li>Whitelist thread-safe/temporally immutable primitives</li>
<li>violations or best effort faulure result in a seuqnetial schedule</li>
<li>Otherwise</li>
<li>Nothing changes</li>
<li>Current JavaScript programs are unaffected</li>
</ul>
<p>→ The sweet spot between Functional and OO</p>
<p>WH: Examples of whitelisting?</p>
<p>RH: Math.sin</p>
<p>WH: Calculating the sine might be parallelizable, but are the lookup of the name and object used to invoke it parallelizable? My biggest concerns are with the glue stuff such as variable and object accesses, which might hit a proxy, observer, or whatnot.</p>
<p>RH: It’s a QoS issue. Start with everything blacklisted, then let implementations figure out what to optimize/whitelist.</p>
<p>WH: If I dont know what the impl does, what am i allowed to do to stay in this efficient realm</p>
<p>NM: Building tools that will help developers see what operations are causing de-opts, general jit feedback</p>
<p>MM: With the JIT optimization, you're comfortable knowing the jit will do its job</p>
<p>WH/YK/MM/AR: (Disagreement)</p>
<p>AR: I maintain a hierarchical constraint solver and must pay close attention to keeping math operations on the same numeric path (note: maintaining values as integer or float)</p>
<p>NM: For best performance, parallel code wants to do the same. We expect better developer tools will be very helpful for both cases.</p>
<p>WH: I want to know specifically how to stay within the good performance safe-harbor</p>
<p>NM: Yes, but we don't have a complete picture.</p>
<p>WH: Want at least a safe harbor subset described. Having users study the idiosyncrasies of a specific implementation to discover it just leads to fragmentation.</p>
<p>TS: Recommend best practices document, vs. specification text</p>
<p>WH: Standards can clearly suggest. For example, the C++ standard has done that by naming the safe harbor conditions that allow the RVO and NRVO optimizations. Implementations can go even further than the cases named in the standard, but users can expect to have at least those optimization cases work efficiently.</p>
<p>NM: I can see an addendum that includes this, but we're not there yet. It takes time to figure out what the common subset is. I expect we'll eventually be able to say this with more precision.</p>
<p>WH: Where on the spectrum between stylized mostly machine-generated code (asm.js) and general-purpose user-written code can we expect the optimizable subset to be?</p>
<p>NM: Much closer to general purpose user-written code.</p>
<p>RH: There will be a sweet spot where this will be very effective. Progress will show</p>
<p>RH: (continuing)</p>
<p>Parallel JavaScript API (ES7)</p>
<ul>
<li>Extend JavaScript's</li>
</ul>
<p>(Need slide)</p>
<p><strong>Sum using reducePar</strong></p>
<pre><code class="language-js"><span class="hljs-comment">// Sequential</span>
<span class="hljs-keyword">var</span> i;
<span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];
<span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i&lt; a.length; i++) {
  sum+= a[i];
}
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// Data Parallel</span>
<span class="hljs-keyword">var</span> pa = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];
... need slide.

</code></pre>
<p>Reverse</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> pa = <span class="hljs-built_in">Array</span>.buildPar(<span class="hljs-number">4</span>, i =&gt; i);
<span class="hljs-keyword">var</span> reversed = pa.scatterPar(<span class="hljs-function">(<span class="hljs-params">a, index, c</span>) =&gt;</span> c.length - index - <span class="hljs-number">1</span>); <span class="hljs-comment">// [3,2,1,0]</span>
</code></pre>
<p>Positive</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> pa = [<span class="hljs-number">1</span>,<span class="hljs-number">-7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>];
<span class="hljs-keyword">var</span> positive = pa.filterPar(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e &gt; <span class="hljs-number">0</span>); <span class="hljs-comment">// [1, 3, 5]</span>
</code></pre>
<p>WH: Is there a similar thing to (common lisp) mapcan? [In Common Lisp mapcan is a map which calls a function on each element. The function returns a list and mapcan returns the concatenation of those lists. The JS equivalent would be the same except using arrays instead of lists.] When writing code I found mapcan to be one of the most useful mappers.</p>
<p>NM: We don't currently have a flatMap operation. It can be done in parallel but requires multiple passes. Could be done in user code.</p>
<p>WH: Doing it in user code makes it hard to optimize well. A built-in would offer more opportunities for an implementation to optimize it by expressing what the user is doing much more directly.</p>
<p>NM: Let's follow up off line</p>
<p>LH: I've noticed that these are all defined on arrays, but used to be on Typed Array</p>
<p>NM: On both</p>
<p>LH: These are consuming and producing arrays, is there a lot of overhead? You'll have an allocation</p>
<p>DL: (Dmitry, please fill in)</p>
<p>NM: The API is important, but we haven't worked on it.</p>
<p>RH: (continuing)</p>
<p><strong>Non-Determinism</strong></p>
<p>(see slide)</p>
<p>MM, WH: Why do the arrows on the slide cross? Why require reduce combinators to be commutative?</p>
<p>NM: For parallelism.</p>
<p>MM, WH: Why? Only associative is needed for parallelism.</p>
<p>TS: eg. if you try to do addition, 100 threads on GPU and doing addition as atomic operation, can’t guarantee commutativity</p>
<p>WH: If you're able to compile the reduce operation into an atomic add, just do it. If you know enough to compile it into an atomic add, you also know that atomic add is commutative.</p>
<p>WH: If you have something more complex, assume it's associative but don't assume it's commutative. It significantly limits the applicability of the algorithms.</p>
<p>NM: I’ll do some more measurements and come back with data.</p>
<p>MM: When the elemental function is commutative, in that case, use whatever technique you want to preserve associativity</p>
<p>YK: You may want to allow people to say that</p>
<p>WH: I want to see, in practice, if that makes a difference</p>
<p>TS: What's a non-trivial example of a noncommutative reduce operator?</p>
<p>MM: Matrix multiplication is associative and non-commutative</p>
<p>RH: (continuing)</p>
<p><strong>Spec Wording</strong></p>
<p>reducePar and scanPar use values from the original <code>O</code> array and results pusged onto an <code>A</code> array</p>
<p>&quot;repeat in an arbitary and implementation dependent order len-1 times.&quot;
&quot;select 2 previously unselected indices, k1 and k2 from <code>O</code> and <code>A</code>&quot;</p>
<p>WH: What is the result of reducePar when the input is an empty array?</p>
<p>Agreement to follow the same empty array behaviour currently defined by <code>Array.prototype.reduce</code></p>
<p><strong>Why Parallel Versions</strong></p>
<p>Sufficiently sophisticated copiler argument</p>
<ul>
<li>new semantics to reduce, scan</li>
</ul>
<p>... need slide.</p>
<p><strong>What we have learned</strong></p>
<ul>
<li>We can see the horizon and there are no show stoppers</li>
<li>Multiple prototypes: Intel(FF, <a href="https://github.com/crosswalk-project/v8-crosswalk">V8/Crosswalk</a>)</li>
<li>Production: Mozilla closely tracking spec</li>
<li>Scaling is achievable in parallelizale parts of the application</li>
<li>Falling back to sequential schedule better than throw</li>
<li>Out pointers to kernal functions are useful for reducing memory pressure and avoidng copying</li>
<li>Allocation pressure is crucial to performance in larger kernels</li>
</ul>
<p><strong>Pressure on Memory Management Latency</strong></p>
<p>(just wait for slides)</p>
<p>MM: Earlier said whitelisting things known to be immutable or threadsafe?</p>
<p>RH: No, have to define &quot;thread safe&quot;</p>
<p>NM: have not done that, want to replay executions without side effects</p>
<p><strong>Next Steps</strong></p>
<p>(copy slides)</p>
<p>(end)</p>
<p>LH: There was other work that Brendan had shown, re: SIMD. Is that still for ES7?</p>
<p>NM: (recapping current progress, no answer for ES7)</p>
<p>Mixed discussion about comprehensions, the introduction of .buildPar, filterPar, reducePar, mapPar</p>
<p>TS: As we added parallel versions of map, reduce, etc. needed parallel of comprehesions which is buildPar</p>
<p>MM/JH: (substantial use of comprehensions in other languages)</p>
<p>WH: Desire to have a parallel comprehension syntax.</p>
<p>?: Why not just optimize the current comprehension syntax?</p>
<p>WH: For exactly the same reason why we're discussing parallel map et al instead of reusing map: it's hard in general to tell whether calls to functions can be reordered.</p>
<p>LH: (subjectively) the comprehension form is more attractive</p>
<a href="#signature-of-arrayfrom-map-callback"><h2 id="signature-of-arrayfrom-map-callback">Signature of Array.from map callback</h2></a><p>(Allen Wirfs-Brock)</p>
<p>AWB: Currently differs in callback arguments:</p>
<p>.from</p>
<pre><code class="language-js">callback.call(thisValue, v)
</code></pre>
<p>.map:</p>
<pre><code class="language-js">callback.call(thisValue, v, i, source);
</code></pre>
<p>RW: The change is supported in Map.prototype.forEach, Set.prototype.forEach, where the last argument is the set or map</p>
<p>AWB: But what can you actually do with that source object if it is just an iterator object?</p>
<p>JH: What</p>
<p>AWB: Consider scenario where someone might want to use the same map callback function for old-style map callback functions + Array.from</p>
<p>AWB: Functions that try to index into an iterator (3rd param) would get undefined, because its an iterator -- not an array</p>
<p>RW: There's a 3rd case for index, eg. tracking index for conditional execution (eg. even/odd element). Might concede the 3rd argument</p>
<p>AWB: Map.prototype.forEach() passes key (for &quot;index&quot; param). Set.prototype.forEach() passes element</p>
<p>AWB: Obscuring errors if arguments don't match expectations</p>
<p>RW: This is a user-code problem</p>
<p>JH: Could we leave it out and require a free variable?</p>
<p>RW: Would be weird that the Array mappers don't leave out the 3rd argument</p>
<p>RH: We find the index very valuable for picking up stuff from free vars</p>
<p>RW: Let's provide index/key for both paths, but not the 3rd param. If you need that you can use a closed over free-var</p>
<a href="#conclusionresolution-signature-of-arrayfrom-map-callback"><h4 id="conclusionresolution-signature-of-arrayfrom-map-callback">Conclusion/Resolution</h4></a><ul>
<li>Change usingIterator path callback signature to: value, index</li>
<li>Change array like path callback signature to: value, index</li>
<li>Removes &quot;items&quot; from 17.d.3.1 (array like path)</li>
<li>Adds &quot;k&quot; to 8.g.7.1
(Noted: <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=904723">https://bugzilla.mozilla.org/show_bug.cgi?id=904723</a>)</li>
</ul>
<a href="#bug-1571-regexp-syntax"><h2 id="bug-1571-regexp-syntax">Bug 1571 RegExp Syntax</h2></a><p><a href="https://bugs.ecmascript.org/show_bug.cgi?id=1571">https://bugs.ecmascript.org/show_bug.cgi?id=1571</a></p>
<p>AWB: ES5 changed (?=) and (?!) from zero-width atoms to assertions</p>
<ul>
<li>Doesn't match reality</li>
<li>Why was this change made?</li>
<li>Should we roll it back?</li>
</ul>
<p>LH: If web reality matches 1571</p>
<ul>
<li>we don't know the motivation</li>
<li>we don't know who or why</li>
</ul>
<p>MB, WH: Roll the change back to ES3, all browsers match ES3 behaviour</p>
<p>AWB: Need to update the ES6 web reality</p>
<p>DC: Did this make it into the bug suites?</p>
<p>LH: Must not have, because no major browser is failing.</p>
<p>WH: How much does test262 test detection of syntax errors?</p>
<p>BT: A lot but probably not enough</p>
<a href="#conclusionresolution-bug-1571-regexp-syntax"><h4 id="conclusionresolution-bug-1571-regexp-syntax">Conclusion/Resolution</h4></a><ul>
<li>Roll back the ES5 change</li>
</ul>
<a href="#change-escapesequence-0-lookahead-∉-decimaldigit-to-match-reality"><h2 id="change-escapesequence-0-lookahead-∉-decimaldigit-to-match-reality">Change “EscapeSequence 0 [lookahead ∉ DecimalDigit]” to match reality</h2></a><p><a href="https://bugs.ecmascript.org/show_bug.cgi?id=1553">https://bugs.ecmascript.org/show_bug.cgi?id=1553</a></p>
<p>AWB: Strict mode explicitly disallows octal escapes.</p>
<p>MB: Technically <code>\08</code> isn't an octal escape sequence though since <code>8</code> is not an octal digit; not sure if the strict mode rule applies</p>
<p>LH: We should take this offline</p>
<p>WH: Not a DecimalIntegerLiteral, which can only have one digit if it starts with a zero.</p>
<p>?: So '\08' is a null followed by '8'.</p>
<p>WH: No, it's not that either. The grammar has a lookahead restriction that states that a decimal integer escape cannot be followed by a digit. It's a syntax error.</p>
<a href="#conclusionresolution-change-escapesequence-0-lookahead-∉-decimaldigit-to-match-reality"><h4 id="conclusionresolution-change-escapesequence-0-lookahead-∉-decimaldigit-to-match-reality">Conclusion/Resolution</h4></a><ul>
<li>Follow up on the bug report
(AWB: who/how?  Action items without names don't get done...)</li>
</ul>
<a href="#implementation-dependencies-in-stringprototypereplace"><h2 id="implementation-dependencies-in-stringprototypereplace">Implementation Dependencies in String.prototype.replace</h2></a><p>AWB: 21.1.3.14 &quot;Table 40 — Replacement Text Symbol Substitutions&quot;: someone should research what implementations do here (any differences or “web reality” to match?)</p>
<p>This issue dates back to ES3</p>
<a href="#conclusionresolution-implementation-dependencies-in-stringprototypereplace"><h4 id="conclusionresolution-implementation-dependencies-in-stringprototypereplace">Conclusion/Resolution</h4></a><ul>
<li>LH to follow up</li>
</ul>
<a href="#regexp-tostring-escaping-not-fully-specified"><h2 id="regexp-tostring-escaping-not-fully-specified">RegExp toString escaping not fully specified</h2></a><p>AWB: 21.2.5.13 may need a more explicit spec.</p>
<p>WH: This was intentional when we defined toString in ES3. If the RegExp is constructed from a string, the string is not always usable as-is due to issues such as //, ///, and others. Evolution of regexps to support non-BMP unicode may introduce other cases due to the cover grammar.</p>
<p>WH: Given that the source string is not usable as-is, there is no obvious unique value that toString ought to return. An implementation might choose to optimize or simplify regexp patterns (example: replace /[zzzzz][.]\u0041/ with /z.A/), and implementations may differ in how far they go in such optimizations. In ES3 we decided to specify the behavior of the returned string: if eval'd, it must produce an identically behaving RegExp. Don't see anything that would invalidate that decision since then.</p>
<p>MB: Browsers currently re-use the exact pattern, e.g. <code>String(/a/)</code> vs. <code>String(/\x61/)</code> – normalization/serialization would be welcome</p>
<p>RW: ES3 spec says &quot;...src may or may not be identical to the source property....&quot; when referring to whether <code>RegExp.prototype.toString()</code> should return the same pattern given to it
...This language disappears in ES5</p>
<ul>
<li>ES3 15.10.6.4</li>
<li>ES5 15.10.6.4</li>
<li>ES6 21.2.5.13</li>
</ul>
<p>MB: <code>eval( RegExp(string) )</code> may not result as intended e.g. if string is <code>'/'</code> or <code>''</code>.</p>
<p>WH: specifying toString completely is a can of worms; instead we should add a requirement that leaves the exact <code>toString</code> behavior up to the implementation, as long as <code>eval( RegExp(string))</code> returns a regular expression that has identical behavior.</p>
<p>?: Not all browsers correctly implement the rule that RegExp toString results must be evalable into the same regular expression.</p>
<p>WH: That would be a browser bug.</p>
<p>AWB: Some browsers haven't been paying close attention to this.</p>
<p>WH: Best fixable by putting a few test cases in test262.</p>
<a href="#conclusionresolution-regexp-tostring-escaping-not-fully-specified"><h4 id="conclusionresolution-regexp-tostring-escaping-not-fully-specified">Conclusion/Resolution</h4></a><ul>
<li>Leave <code>RegExp.prototype.toString</code> definition as-is, but consider adding requirement <a href="https://bugs.ecmascript.org/show_bug.cgi?id=2609">https://bugs.ecmascript.org/show_bug.cgi?id=2609</a></li>
</ul>
<a href="#allens-todo-summary"><h2 id="allens-todo-summary">Allen's TODO Summary</h2></a><ul>
<li>Lots of Module related cleanup and refinement</li>
<li>new eval semantics</li>
<li>MOP/Proxy property enumeration API</li>
<li>Cleanup completion reform and issues (nothing insurmountable)</li>
<li>Need to write Annex B spec for HTML-like comments</li>
</ul>
<p>BT: Can you describe the &quot;MOP/Proxy property enumeration API&quot; item?</p>
<p>AWB: There are outstanding enumeration issues that we need to finally address.</p>
<a href="#introduction-and-language-overview"><h2 id="introduction-and-language-overview">Introduction and Language Overview</h2></a><ul>
<li>Need ES6 paragraph for intro (Brendan?)</li>
<li>Need somebody to update language overview</li>
<li>In rev23 added some material about classes and how they related to the prototype discussion</li>
</ul>
<a href="#conclusionresolution-introduction-and-language-overview"><h4 id="conclusionresolution-introduction-and-language-overview">Conclusion/Resolution</h4></a><ul>
<li>RW volunteers to write first draft of language overview</li>
</ul>
<p>LH: Is the recent work you've done on scope complete?</p>
<p>AWB: Still have work to do on eval scope</p>
<p>BT: That's whether or not there is an implied block</p>
<p>RW: This is not to say that <em>literally</em> the difference is the addition of &quot;{&quot; + source + &quot;}&quot;, but that you could reason about the result in such a way</p>
<p>AWB/LH: Approximately.</p>
<p>...re: Modules</p>
<p>JM: Can work to help Dave extract Module knowledge</p>
<p>RW: Review, find missing parts, report it (bugs, to Dave, etc)</p>
<p>AWB: HTML comments syntax should be specified for Annex B <a href="https://bugs.ecmascript.org/show_bug.cgi?id=2610">https://bugs.ecmascript.org/show_bug.cgi?id=2610</a></p>
<a href="#es7-process-new-proposal-home"><h2 id="es7-process-new-proposal-home">ES7 Process, New Proposal Home</h2></a><p><a href="https://github.com/tc39/ecma262">https://github.com/tc39/ecma262</a></p>
<p>AWB/BT/LH/RW: mixed discussion and agreement to replace the wiki.</p>
<a href="#conclusionresolution-es7-process-new-proposal-home"><h4 id="conclusionresolution-es7-process-new-proposal-home">Conclusion/Resolution</h4></a><ul>
<li>All in favor!</li>
</ul>
<p>RW: Should this github repo contain actual proposal info?</p>
<p>BT: Haven't decided yet, but seems reasonable</p>
<p>RW: Will hold off until the organizational story is complete.</p>
<p>RW: We should have a guideline on format for linked proposals (see <a href="http://wiki.ecmascript.org/doku.php?id=strawman:string_padding">http://wiki.ecmascript.org/doku.php?id=strawman:string_padding</a> as a possible example)</p>
<p>Discussion about what topics should be in this guideline</p>
<ul>
<li>History</li>
<li>Use Cases</li>
<li>Problems/Pain points addressed</li>
</ul>
<p>BT: (to YK) send a PR with your proposal proposal.</p>
<p>JN: Please review the review sign up sheet and sign up.</p>
<a href="#44-objectgetownpropertydescriptors"><h2 id="44-objectgetownpropertydescriptors">4.4 Object.getOwnPropertyDescriptors</h2></a><p>(Rick Waldron)</p>
<p>RW: this is the analog of defineProperties
This is for ES7.</p>
<p>MM: Returns array or iterator?</p>
<p>RW: It returns a plain object that can be passed directly to defineOwnProperties</p>
<p>MM: Does it inherit from Object.prototype?</p>
<p>RW: Uknown. Open issue.</p>
<p>WH: What if you have a proxy that represents a massively infinite structure, what does this do?</p>
<p>RW: Unknown. Open issue.
No reason to rush, this is an ES7 thing.</p>
<p>AWB: Must be same answer as what you get from getOwnPropertyNames</p>
<p>RW: Makes sense.</p>
<p>DC: Returns things that are not enumerable?</p>
<p>RW: Yes.</p>
<p>MM: I have no problem with this. What about symbol properties?</p>
<p>AWB: Open issue.</p>
<p>MM: This one is a trivial polyfill.</p>
<p>AWB: Any library can implement this. They should experiment and figure out what's useful.</p>
<p>YK: There are many issues. Would be best for us to decide what the right behavior is.</p>
<p>AWB: If you have a complex object you don't necessarily want to create all these property descriptors... Lots of allocations that get thrown out immediately. May not be a good idea.</p>
<p>YK: Maybe you want a fn with a callback that yields in the value</p>
<p>AWB: Or something like iterator but it doesn't necessarily fit.</p>
<p>MM: There might already be a polyfill in the Traits.js library.</p>
<p>WH: Why does it return an object instead of matching the behavior of Reflect.ownKeys?</p>
<p>RW: To pass to O.dPs</p>
<p>BN: Why no 'own' in the name even though they make own properties.</p>
<p>AWB: History - you can imagine dealing with own properties and inherited properties, you have to make a choice about which you deal with. Methods explicitly have own in it. In situations where the only thing you could deal with drop the 'own'. Defining implies own.</p>
<p>BN: Descriptors is so verbose... why?</p>
<p>RW: You get back a descriptor. There is already a getOwnPropertyDescriptor.</p>
<p>ACHIEVEMENT UNLOCKED: Longer API name than getOwnPropertyDescriptor!</p>
<a href="#conclusionresolution-44-objectgetownpropertydescriptors"><h4 id="conclusionresolution-44-objectgetownpropertydescriptors">Conclusion/Resolution</h4></a><ul>
<li>Pursue for ES7. RW has spec text. Approved for Stage 0.</li>
<li>RW to send a PR to add to github.com/tc39/ecma262 tracker</li>
</ul>
<a href="#45-arrayprototypecontains"><h2 id="45-arrayprototypecontains">4.5 Array.prototype.contains</h2></a><p>(Rick Waldron)</p>
<p>RW: ES5 adds String.prototype.contains. Seems oversight that we don't have the same thing in Array. But, we can wait until ES7.</p>
<p>BT: Any spec text?</p>
<p>RW: Not yet, just mailing list discussions.</p>
<p>WH: Are you searching for elements or subsequences? If goal is to be analogous with string you would be searching for subsequences.</p>
<p>DC: We didn't do that for <code>indexOf</code>... Rick suggests continuing in that tradition.</p>
<p>WH: That's confusing. If it's not analogous, it should have a different name...</p>
<p>MB: Would be nice for DOM (would get rid of abstractions). DOM has <code>contains</code> for classList.</p>
<p>YK: Why not use <code>has</code> like set?</p>
<p>MB: Because <code>classList</code> already uses <code>contains</code>.</p>
<p>BT: Is this different than <code>indexOf</code>?</p>
<p>RW: Open question.</p>
<a href="#conclusionresolution-45-arrayprototypecontains"><h4 id="conclusionresolution-45-arrayprototypecontains">Conclusion/Resolution</h4></a><ul>
<li>Sounds good, need strawman to approve stage 0.</li>
</ul>
<a href="#46-updates-to-parseint"><h2 id="46-updates-to-parseint">4.6 Updates to parseInt</h2></a><p>(Rick Waldron)</p>
<p>RW: Should <code>parseInt</code> handle new octal and binary integer literal syntax? <a href="https://bugs.ecmascript.org/show_bug.cgi?id=1585">bug #1585</a></p>
<p>WH: Which octal syntax? 0123 or 0o123?</p>
<p>RW: 0[OoBb]<suitabledigits> only.</p>
<p>AWB: Essentially add the new literal syntax to <code>parseInt</code>.</p>
<p>WH: Sounds great, love to do it. But are there security problems? For example, let's say you have a website that parses the same 0o123 integer twice, one time uses <code>parseInt</code>, other time uses something else that isn't aware of the new prefixes and thinks that parseInt would return 0. Validation might pass but actual value would be wrong.</p>
<p>RW: Doesn't this exist with hex integer literals?</p>
<p>WH: No, hex literal has been around since the beginnning... These would be new. It's a breaking change.</p>
<p>MM: What is the rule that you propose to recognize an octal literal?</p>
<p>RW: Those in the spec: 0b/0B or 0O/0o.</p>
<p>LH: This works today (returns <code>0</code>). This is a breaking change...</p>
<p>AWB: Applications may not want this behavior...</p>
<p>MB: You can use <code>Number(&quot;0b11&quot;)</code> or <code>Number(&quot;0o42&quot;)</code> instead, at least in V8. (<code>ToNumber</code> in the spec should be updated to make this official: <a href="https://bugs.ecmascript.org/show_bug.cgi?id=1584">https://bugs.ecmascript.org/show_bug.cgi?id=1584</a>)</p>
<p>LH: Was that a breaking change? Looks like, but we went from <code>NaN</code> to actually returning a number.</p>
<p>WH: It's a breaking change. parseInt looks for a valid prefix and ignores the rest. parseInt('0o123') currently returns 0 because it sees the starting 0.</p>
<a href="#conclusionresolution-46-updates-to-parseint"><h4 id="conclusionresolution-46-updates-to-parseint">Conclusion/Resolution</h4></a><p>It's dead. RW to close the bug wontfix.</p>
<a href="#43-update-objectassign-to-accept-multiple-sources"><h2 id="43-update-objectassign-to-accept-multiple-sources">4.3, Update Object.assign to accept multiple sources</h2></a><p>(Rick Waldron)</p>
<p>RW: <code>Object.assign</code> is useful. Multiple real-world APIs do this, but most allow multiple sources.</p>
<p>AWB: Some have additional options (enumerable vs. non-enumerable, shallow vs. deep copy).</p>
<p>RW: We selected an appropriate name (assign) that set it apart from existing APIs (ie. extend, or merge). We got consensus on this. Problem is that the response from practitioners has been negative. They want a multiple sources version.</p>
<p>EF: Didn't we solve that with reduce?</p>
<p>RW: Somewhat, but it introduces a bug.</p>
<p>RW: I tend to agree it falls short of the cowpath. We should fix for ES6.</p>
<p>YK: one of the common use cases for assign where you're supporting multiple mixins</p>
<p>BT: Why is name important?</p>
<p>AWB: Anyone else who has defined <code>Object.&lt;that name&gt;</code> could clobber existing stuff.</p>
<p>SM: Want an immutable version?</p>
<p>RW: Workaround - just use first source as empty object.</p>
<p>AWB: We considered that in the future we might want to add an options record. We weren't trying to provide an end-user solution but a primitive.</p>
<p>EF: If we only had support for one source and target and people used the reduce pattern we could break the web in the future if we want to extend this later.</p>
<p>RW: It will be a WTF that we ignored the cowpath.</p>
<p>AWB: That's why we chose a different name. This isn't <code>extends</code>.</p>
<p>YK: It's about real use cases.</p>
<p>WH: Why do the existing methods ignore exceptions?</p>
<p>MM: If some props cause exceptions and others don't, rather than have it be random which prop took, you have a gaurantee that all non-exceptional properties took. Do same thing with DP.</p>
<p>BT: What options?</p>
<p>AWB: Filter function, whether symbols are used.
:: Discussion about whether and what was discussed previously, confirmed prevous consensus was target and source previously, but we didn't explicitly say multiple sources was out ::</p>
<p>YK: We decided that we were going to do assign now, and punt on more complex APIs for ES7. We don't need copying APIs for very specific use cases.</p>
<p>RW: this is a super common use case.</p>
<p>AWB: Most common is single source + target</p>
<p>YK: People will want multiple sources and won't see it as different API.</p>
<p>AWB: Concern that for people who are doing mixins, this is the wrong primitive thing.</p>
<p>YK: Won't happen. Doesn't rebind <code>super</code>. So we need ES7 to handle <code>super</code> correctly.</p>
<p>BE: Who's against?</p>
<p>AWB: I'm not enthusiastic. Won't stand in the way.</p>
<p>BE: Seems strictly winning to have multiple arguments.</p>
<a href="#conclusionresolution-43-update-objectassign-to-accept-multiple-sources"><h4 id="conclusionresolution-43-update-objectassign-to-accept-multiple-sources">Conclusion/Resolution</h4></a><ul>
<li>Object.assign gets multiple source objects.</li>
</ul>
<a href="#51-objectentries-objectvalues"><h2 id="51-objectentries-objectvalues">5.1 Object.entries, Object.values</h2></a><p>(Rick Waldron)</p>
<p>RW: ES5 added <code>Object.keys</code>. For ES7, <code>Object.entries</code> and <code>Object.values</code> make sense. These return arrays.</p>
<p>BT: Array of arrays for <code>entries</code>?</p>
<p>RW: Yes. You can pass to Map constructor.</p>
<p>YK: Important to be iterable.</p>
<p>AWB: Why not return iterator?</p>
<p>RW: Agree it's crappy but it makes sense because keys returns array.</p>
<p>AWB: Alternatively we could add this to a standard <code>Dict</code> module.</p>
<p>BT: Assuming we get standard modules?</p>
<p>AWB: We'll get them.</p>
<a href="#conclusionresolution-51-objectentries-objectvalues"><h4 id="conclusionresolution-51-objectentries-objectvalues">Conclusion/Resolution</h4></a><ul>
<li>Need strawman for stage 0</li>
</ul>
<a href="#test-262-update"><h2 id="test-262-update">Test 262 Update</h2></a><p>BT: A lot of pull requests piling up
... Domenic will port promise tests
... Awaiting the contributor agreement form</p>
<p>BN: Will contribute Generator tests</p>
<p>BT: Also need syntax tests</p>
<p>DL: V8 is beginning to implement ES6 and will want to contribute back the tests</p>
<p>RW: We'll need to update the current PRs with any guidelines</p>
<p>MM: For tests that are not specifically specified as strict-only or sloppy-only, currently the test262 harness only tests these in sloppy mode. Must test these in both strict and sloppy by default.</p>
<p>BT: Issues with the error message string varying across platforms</p>
<p>BT: Also need cross realm association testing
...Naively, we could write in-browser tests, but ideally we want host-agnostic testing.</p>
<p>AWB: Need to stay up to date with reviewing</p>
<p>BT: Rick and I have been doing this</p>
<p>DL: V8 team can assist as well</p>
<p>BT: Will need to support a variety of disparate test systems</p>
<p>MB: What about Annex B tests? They’d have to run in a browser; test runner needs to support that somehow.</p>
<p>MM: Detect Annex B features, then if they’re present, test if they behave as per the spec, if not, fail silently.</p>
<p>BT: Continue to report test coverage gaps.</p>
<a href="#conclusionresolution-test-262-update"><h4 id="conclusionresolution-test-262-update">Conclusion/Resolution</h4></a><ul>
<li>BT to publish test criteria/guidelines</li>
<li>Inform current contributors of guidelines to prepare</li>
<li>Establish rules for testing Annex B</li>
</ul>
<a href="#async-functions-question"><h2 id="async-functions-question">Async Functions Question</h2></a><p>(Jafar Husain)</p>
<p>JH: Question about the omission of the <code>close()</code> method from iterator</p>
<p>BE: <code>close</code> came from Python, was on generator objects. We unified send and next, we didn't include <code>close</code>.</p>
<p>JH: To be specific, I want the object returned by <code>@@iterator</code> to include a <code>close()</code> method.</p>
<p>BE: The problem with <code>close</code> in python is that it leaks GC semantics.</p>
<p>JH: I understand this isn't based on IEnumerator, but think there is a important case being missed.</p>
<p>MM: I like this addition</p>
<p>BE: we solved by making <code>close</code> automatic</p>
<p>DL: If you have <code>close</code>, and have <code>try</code>/<code>finally</code> there is no guarantee that the <code>close</code> is called.</p>
<p>BE: In a browser, to avoid denial of service, <code>finally</code> is not guaranteed to run.</p>
<p>AWB: Iterator prototocol doesn't require implementing throw, so that the iterator must only implement <code>next</code></p>
<p>BE: Andy Wingo presented cases for removal <a href="https://mail.mozilla.org/pipermail/es-discuss/2013-May/030683.html">https://mail.mozilla.org/pipermail/es-discuss/2013-May/030683.html</a></p>
<p>Discussion about whether this is a breaking change, resolution - it is but probably not a big deal</p>
<p>The name &quot;return&quot; is more accurate then &quot;close&quot;</p>
<p>LH: We need a write up that explains why this is critical</p>
<p>RW: (to JH) confirm a write up for tomorrow</p>
<p>Discussion about &quot;reserving&quot; names on iterator objects.</p>
<p>BE: A symbol for the name of the method?</p>
<p>The risk is not big enough</p>
<p>JH: ES6 for-of won't look for a <code>return()</code> method, but ES7 for-of will look for it and invoke.</p>
<p>BE: Deeper issue, we had <code>close</code>, but we got rid of it. Was it because no one used it as presented, or was because Andy's points were sufficiently convincing.</p>
<p>YK: Having <code>close()</code> exist cause hazards?</p>
<p>BE: No</p>
<p>BN: You might break the for-of to exhaust the iterator elsewhere.</p>
<p>MM: Under this proposal, when the for-of exits early (break) it would cause the generator to take the exit path. If we do this, we have to do this in ES6. It's sufficiently weird enough that I'm not convinced.</p>
<p>YK: You'd opt in?</p>
<p>LH/MM: no</p>
<p>MM: If the for-of exits early, the <code>return()</code> on the generator is called</p>
<p>This <em>must</em> be done in ES6, if done at all.</p>
<p>JH: Similar to <code>Object.unobserve</code>, sometimes you want to stop doing something that you've started.</p>
<p>Discussion about ways around and reasons for use.</p>
<p>MM: What if we modify: no explicit close/return on exit of for-of. generator objects have this method, but must be explicitly called.</p>
<p>JH: That allows for a future syntactic form?</p>
<p>MM: Probably wouldn't add syntactic form.</p>
<p>LH: Worried about the whole notion of having a return mechanism on generator objects (referring to the example given by Andy Wingo, item 2, surprising yield behaviour).</p>
<p>JH: If for-of doesn't explicitly call the <code>return()</code>?</p>
<p>BE: That's addressed by item 3 in Andy's concerns</p>
<p>MM: You could still do this by writing out manually</p>
<p>JH: Yes</p>
<p>BE: Recap: no explicit for-of semantics, has a <code>return()</code> that can be called if needed?</p>
<p>BN: may want <code>return()</code> to exit without triggering catch, vs. <code>throw()</code></p>
<p>MM: Please present use cases that illustrate</p>
<p>JH: Confirmed.</p>
<a href="#conclusionresolution-async-functions-question"><h4 id="conclusionresolution-async-functions-question"><del>Conclusion/Resolution</del></h4></a><ul>
<li><del>Generator.prototype.return()</del></li>
</ul>
<p>(continued to April 10, 2014)</p>

</body>